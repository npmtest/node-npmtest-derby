{"/home/travis/build/npmtest/node-npmtest-derby/test.js":"/* istanbul instrument in package npmtest_derby */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-derby/lib.npmtest_derby.js":"/* istanbul instrument in package npmtest_derby */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_derby = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_derby = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-derby/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-derby && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_derby */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_derby\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_derby.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_derby.rollup.js'] =\n            local.assetsDict['/assets.npmtest_derby.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_derby.__dirname + '/lib.npmtest_derby.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/index.js":"var Derby = require('./lib/Derby');\nmodule.exports = new Derby();\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/Derby.js":"/*\n * Derby.js\n * Meant to be the entry point for the framework.\n *\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar racer = require('racer');\nvar App = require('./App');\nvar Page = require('./Page');\nvar components = require('./components');\n\nmodule.exports = Derby;\n\nfunction Derby() {}\nDerby.prototype = racer;\n\nDerby.prototype.App = App;\nDerby.prototype.Page = Page;\nDerby.prototype.Component = components.Component;\n\nDerby.prototype.createApp = function(name, filename, options) {\n  return new App(this, name, filename, options);\n};\n\nif (!racer.util.isServer) {\n  require('./documentListeners').add(document);\n}\n\nracer.util.serverRequire(module, './Derby.server');\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/App.js":"/*\n * App.js\n *\n * Provides the glue between views, controllers, and routes for an\n * application's functionality. Apps are responsible for creating pages.\n *\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar tracks = require('tracks');\nvar util = require('racer/lib/util');\nvar derbyTemplates = require('derby-templates');\nvar documentListeners = require('./documentListeners');\nvar Page = require('./Page');\nvar serializedViews = require('./_views');\n\nmodule.exports = App;\n\nfunction App(derby, name, filename, options) {\n  EventEmitter.call(this);\n  this.derby = derby;\n  this.name = name;\n  this.filename = filename;\n  this.scriptHash = '{{DERBY_SCRIPT_HASH}}';\n  this.bundledAt = '{{DERBY_BUNDLED_AT}}';\n  this.Page = createAppPage();\n  this.proto = this.Page.prototype;\n  this.views = new derbyTemplates.templates.Views();\n  this.tracksRoutes = tracks.setup(this);\n  this.model = null;\n  this.page = null;\n  this._init(options);\n}\n\nfunction createAppPage() {\n  // Inherit from Page so that we can add controller functions as prototype\n  // methods on this app's pages\n  function AppPage() {\n    Page.apply(this, arguments);\n  }\n  AppPage.prototype = Object.create(Page.prototype);\n  return AppPage;\n}\n\nutil.mergeInto(App.prototype, EventEmitter.prototype);\n\n// Overriden on server\nApp.prototype._init = function() {\n  this._waitForAttach = true;\n  this._cancelAttach = false;\n  this.model = new this.derby.Model();\n  serializedViews(derbyTemplates, this.views);\n  // Must init async so that app.on('model') listeners can be added.\n  // Must also wait for content ready so that bundle is fully downloaded.\n  this._contentReady();\n};\nApp.prototype._finishInit = function() {\n  var script = this._getScript();\n  var data = JSON.parse(script.nextSibling.innerHTML);\n  this.model.createConnection(data);\n  this.emit('model', this.model);\n  util.isProduction = data.nodeEnv === 'production';\n  if (!util.isProduction) this._autoRefresh();\n  this.model.unbundle(data);\n  var page = this.createPage();\n  page.params = this.model.get('$render.params');\n  this.emit('ready', page);\n  this._waitForAttach = false;\n  // Instead of attaching, do a route and render if a link was clicked before\n  // the page finished attaching\n  if (this._cancelAttach) {\n    this.history.refresh();\n    return;\n  }\n  // Since an attachment failure is *fatal* and could happen as a result of a\n  // browser extension like AdBlock, an invalid template, or a small bug in\n  // Derby or Saddle, re-render from scratch on production failures\n  if (util.isProduction) {\n    try {\n      page.attach();\n    } catch (err) {\n      this.history.refresh();\n      console.warn('attachment error', err.stack);\n    }\n  } else {\n    page.attach();\n  }\n  this.emit('load', page);\n};\n// Modified from: https://github.com/addyosmani/jquery.parts/blob/master/jquery.documentReady.js\nApp.prototype._contentReady = function() {\n  // Is the DOM ready to be used? Set to true once it occurs.\n  var isReady = false;\n  var app = this;\n\n  // The ready event handler\n  function onDOMContentLoaded() {\n    if (document.addEventListener) {\n      document.removeEventListener('DOMContentLoaded', onDOMContentLoaded, false);\n    } else {\n      // we're here because readyState !== 'loading' in oldIE\n      // which is good enough for us to call the dom ready!\n      document.detachEvent('onreadystatechange', onDOMContentLoaded);\n    }\n    onDOMReady();\n  }\n\n  // Handle when the DOM is ready\n  function onDOMReady() {\n    // Make sure that the DOM is not already loaded\n    if (isReady) return;\n    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n    if (!document.body) return setTimeout(onDOMReady, 0);\n    // Remember that the DOM is ready\n    isReady = true;\n    // Make sure this is always async and then finishin init\n    setTimeout(function() {\n      app._finishInit();\n    }, 0);\n  }\n\n  // The DOM ready check for Internet Explorer\n  function doScrollCheck() {\n    if (isReady) return;\n    try {\n      // If IE is used, use the trick by Diego Perini\n      // http://javascript.nwbox.com/IEContentLoaded/\n      document.documentElement.doScroll('left');\n    } catch (err) {\n      setTimeout(doScrollCheck, 0);\n      return;\n    }\n    // and execute any waiting functions\n    onDOMReady();\n  }\n\n  // Catch cases where called after the browser event has already occurred.\n  if (document.readyState !== 'loading') return onDOMReady();\n\n  // Mozilla, Opera and webkit nightlies currently support this event\n  if (document.addEventListener) {\n    // Use the handy event callback\n    document.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);\n    // A fallback to window.onload, that will always work\n    window.addEventListener('load', onDOMContentLoaded, false);\n    // If IE event model is used\n  } else if (document.attachEvent) {\n    // ensure firing before onload,\n    // maybe late but safe also for iframes\n    document.attachEvent('onreadystatechange', onDOMContentLoaded);\n    // A fallback to window.onload, that will always work\n    window.attachEvent('onload', onDOMContentLoaded);\n    // If IE and not a frame\n    // continually check to see if the document is ready\n    var toplevel;\n    try {\n      toplevel = window.frameElement == null;\n    } catch (err) {}\n    if (document.documentElement.doScroll && toplevel) {\n      doScrollCheck();\n    }\n  }\n};\n\nApp.prototype._getScript = function() {\n  return document.querySelector('script[data-derby-app]');\n};\n\nApp.prototype.use = util.use;\nApp.prototype.serverUse = util.serverUse;\n\nApp.prototype.loadViews = function() {};\n\nApp.prototype.loadStyles = function() {};\n\nApp.prototype.createPage = function() {\n  if (this.page) {\n    this.emit('destroyPage', this.page);\n    this.page.destroy();\n  }\n  var page = new this.Page(this, this.model);\n  this.page = page;\n  return page;\n};\n\nApp.prototype.onRoute = function(callback, page, next, done) {\n  if (this._waitForAttach) {\n    // Cancel any routing before the initial page attachment. Instead, do a\n    // render once derby is ready\n    this._cancelAttach = true;\n    return;\n  }\n  this.emit('route', page);\n  // HACK: To update render in transitional routes\n  page.model.set('$render.params', page.params);\n  page.model.set('$render.url', page.params.url);\n  page.model.set('$render.query', page.params.query);\n  // If transitional\n  if (done) {\n    var app = this;\n    var _done = function() {\n      app.emit('routeDone', page, 'transition');\n      done();\n    };\n    callback.call(page, page, page.model, page.params, next, _done);\n    return;\n  }\n  callback.call(page, page, page.model, page.params, next);\n};\n\nApp.prototype._autoRefresh = function() {\n  var app = this;\n  var connection = this.model.connection;\n  connection.on('connected', function() {\n    connection.send({\n      derby: 'app',\n      name: app.name,\n      hash: app.scriptHash\n    });\n  });\n  connection.on('receive', function(request) {\n    if (request.data.derby) {\n      var message = request.data;\n      request.data = null;\n      app._handleMessage(message.derby, message);\n    }\n  });\n};\n\nApp.prototype._handleMessage = function(action, message) {\n  if (action === 'refreshViews') {\n    var fn = new Function('return ' + message.views)(); // jshint ignore:line\n    fn(derbyTemplates, this.views);\n    var ns = this.model.get('$render.ns');\n    this.page.render(ns);\n\n  } else if (action === 'refreshStyles') {\n    var styleElement = document.querySelector('style[data-filename=\"' +\n      message.filename + '\"]');\n    if (styleElement) styleElement.innerHTML = message.css;\n\n  } else if (action === 'reload') {\n    this.model.whenNothingPending(function() {\n      window.location = window.location;\n    });\n  }\n};\n\nutil.serverRequire(module, './App.server');\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby-templates/index.js":"exports.contexts = require('./lib/contexts');\nexports.expressions = require('./lib/expressions');\nexports.operatorFns = require('./lib/operatorFns');\nexports.templates = require('./lib/templates');\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby-templates/lib/contexts.js":"exports.ContextMeta = ContextMeta;\nexports.Context = Context;\n\nfunction noop() {}\n\n// TODO:\n// Implement removeItemContext\n\nfunction ContextMeta() {\n  this.addBinding = noop;\n  this.removeBinding = noop;\n  this.removeNode = noop;\n  this.addItemContext = noop;\n  this.removeItemContext = noop;\n  this.views = null;\n  this.idNamespace = '';\n  this.idCount = 0;\n  this.pending = [];\n  this.pauseCount = 0;\n}\n\nfunction Context(meta, controller, parent, unbound, expression, item, view, attributes, hooks, initHooks) {\n  // Required properties //\n\n  // Properties which are globally inherited for the entire page\n  this.meta = meta;\n  // The page or component. Must have a `model` property with a `data` property\n  this.controller = controller;\n\n  // Optional properties //\n\n  // Containing context\n  this.parent = parent;\n  // Boolean set to true when bindings should be ignored\n  this.unbound = unbound;\n  // The expression for a block\n  this.expression = expression;\n  // Alias name for the given expression\n  this.alias = expression && expression.meta && expression.meta.as;\n  // Alias name for the index or iterated key\n  this.keyAlias = expression && expression.meta && expression.meta.keyAs;\n\n  // For Context::eachChild\n  // The index of the each at render time\n  this.item = item;\n\n  // For Context::viewChild\n  // Reference to the current view\n  this.view = view;\n  // Attribute values passed to the view instance\n  this.attributes = attributes;\n  // MarkupHooks to be called after insert into DOM of component\n  this.hooks = hooks;\n  // MarkupHooks to be called immediately before init of component\n  this.initHooks = initHooks;\n\n  // Used in EventModel\n  this._id = null;\n}\n\nContext.prototype.id = function() {\n  var count = ++this.meta.idCount;\n  return this.meta.idNamespace + '_' + count.toString(36);\n};\n\nContext.prototype.addBinding = function(binding) {\n  // Don't add bindings that wrap list items. Only their outer range is needed\n  if (binding.itemFor) return;\n  var expression = binding.template.expression;\n  // Don't rerender in unbound sections\n  if (expression ? expression.isUnbound(this) : this.unbound) return;\n  // Don't rerender to changes in a with expression\n  if (expression && expression.meta && expression.meta.blockType === 'with') return;\n  this.meta.addBinding(binding);\n};\nContext.prototype.removeBinding = function(binding) {\n  this.meta.removeBinding(binding);\n};\nContext.prototype.removeNode = function(node) {\n  this.meta.removeNode(node);\n};\n\nContext.prototype.child = function(expression) {\n  // Set or inherit the binding mode\n  var blockType = expression.meta && expression.meta.blockType;\n  var unbound = (blockType === 'unbound') ? true :\n    (blockType === 'bound') ? false :\n    this.unbound;\n  return new Context(this.meta, this.controller, this, unbound, expression);\n};\n\nContext.prototype.componentChild = function(component) {\n  return new Context(this.meta, component, this, this.unbound);\n};\n\n// Make a context for an item in an each block\nContext.prototype.eachChild = function(expression, index) {\n  var context = new Context(this.meta, this.controller, this, this.unbound, expression, index);\n  this.meta.addItemContext(context);\n  return context;\n};\n\nContext.prototype.viewChild = function(view, attributes, hooks, initHooks) {\n  return new Context(this.meta, this.controller, this, this.unbound, null, null, view, attributes, hooks, initHooks);\n};\n\nContext.prototype.forRelative = function(expression) {\n  var context = this;\n  while (context && context.expression === expression || context.view) {\n    context = context.parent;\n  }\n  return context;\n};\n\n// Returns the closest context which defined the named alias\nContext.prototype.forAlias = function(alias) {\n  var context = this;\n  while (context) {\n    if (context.alias === alias || context.keyAlias === alias) return context;\n    context = context.parent;\n  }\n};\n\n// Returns the closest containing context for a view attribute name or nothing\nContext.prototype.forAttribute = function(attribute) {\n  var context = this;\n  while (context) {\n    // Find the closest context associated with a view\n    if (context.view) {\n      var attributes = context.attributes;\n      if (!attributes) return;\n      if (attributes.hasOwnProperty(attribute)) return context;\n      // If the attribute isn't found, but the attributes inherit, continue\n      // looking in the next closest view context\n      if (!attributes.inherit && !attributes.extend) return;\n    }\n    context = context.parent;\n  }\n};\n\nContext.prototype.forViewParent = function() {\n  var context = this;\n  while (context) {\n    // Find the closest view\n    if (context.view) return context.parent;\n    context = context.parent;\n  }\n};\n\nContext.prototype.getView = function() {\n  var context = this;\n  while (context) {\n    // Find the closest view\n    if (context.view) return context.view;\n    context = context.parent;\n  }\n};\n\n// Returns the `this` value for a context\nContext.prototype.get = function() {\n  return (this.expression) ? this.expression.get(this) : this.controller.model.data;\n};\n\nContext.prototype.pause = function() {\n  this.meta.pauseCount++;\n};\n\nContext.prototype.unpause = function() {\n  if (--this.meta.pauseCount) return;\n  this.flush();\n};\n\nContext.prototype.flush = function() {\n  var pending = this.meta.pending;\n  var len = pending.length;\n  if (!len) return;\n  this.meta.pending = [];\n  for (var i = 0; i < len; i++) {\n    pending[i]();\n  }\n};\n\nContext.prototype.queue = function(cb) {\n  this.meta.pending.push(cb);\n};\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby-templates/lib/expressions.js":"var serializeObject = require('serialize-object');\nvar operatorFns = require('./operatorFns');\nvar templates = require('./templates');\n\nexports.lookup = lookup;\nexports.templateTruthy = templateTruthy;\nexports.pathSegments = pathSegments;\nexports.renderValue = renderValue;\nexports._outerDependency = outerDependency;\nexports.ExpressionMeta = ExpressionMeta;\n\nexports.Expression = Expression;\nexports.LiteralExpression = LiteralExpression;\nexports.PathExpression = PathExpression;\nexports.RelativePathExpression = RelativePathExpression;\nexports.AliasPathExpression = AliasPathExpression;\nexports.AttributePathExpression = AttributePathExpression;\nexports.BracketsExpression = BracketsExpression;\nexports.FnExpression = FnExpression;\nexports.OperatorExpression = OperatorExpression;\nexports.NewExpression = NewExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ScopedModelExpression = ScopedModelExpression;\n\nfunction lookup(segments, value) {\n  if (!segments) return value;\n\n  for (var i = 0, len = segments.length; i < len; i++) {\n    if (value == null) return value;\n    value = value[segments[i]];\n  }\n  return value;\n}\n\n// Unlike JS, `[]` is falsey. Otherwise, truthiness is the same as JS\nfunction templateTruthy(value) {\n  return (Array.isArray(value)) ? value.length > 0 : !!value;\n}\n\nfunction pathSegments(segments) {\n  var result = [];\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    result[i] = (typeof segment === 'object') ? segment.item : segment;\n  }\n  return result;\n}\n\nfunction renderValue(value, context) {\n  return (typeof value !== 'object') ? value :\n    (value instanceof templates.Template) ? renderTemplate(value, context) :\n    (Array.isArray(value)) ? renderArray(value, context) :\n    renderObject(value, context);\n}\nfunction renderTemplate(value, context) {\n  var i = 1000;\n  while (value instanceof templates.Template) {\n    if (--i < 0) throw new Error('Maximum template render passes exceeded');\n    value = value.get(context, true);\n  }\n  return value;\n}\nfunction renderArray(array, context) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    if (hasTemplateProperty(array[i])) {\n      return renderArrayProperties(array, context);\n    }\n  }\n  return array;\n}\nfunction renderObject(object, context) {\n  return (hasTemplateProperty(object)) ?\n    renderObjectProperties(object, context) : object;\n}\nfunction hasTemplateProperty(object) {\n  if (!object) return false;\n  if (global.Node && object instanceof global.Node) return false;\n  for (var key in object) {\n    if (object[key] instanceof templates.Template) return true;\n  }\n  return false;\n}\nfunction renderArrayProperties(array, context) {\n  var out = [];\n  for (var i = 0, len = array.length; i < len; i++) {\n    var item = renderObject(array[i], context);\n    out.push(item);\n  }\n  return out;\n}\nfunction renderObjectProperties(object, context) {\n  var out = {};\n  for (var key in object) {\n    var value = object[key];\n    out[key] = renderTemplate(value, context);\n  }\n  return out;\n}\n\nfunction ExpressionMeta(source, blockType, isEnd, as, keyAs, unescaped, bindType, valueType) {\n  this.source = source;\n  this.blockType = blockType;\n  this.isEnd = isEnd;\n  this.as = as;\n  this.keyAs = keyAs;\n  this.unescaped = unescaped;\n  this.bindType = bindType;\n  this.valueType = valueType;\n}\nExpressionMeta.prototype.module = 'expressions';\nExpressionMeta.prototype.type = 'ExpressionMeta';\nExpressionMeta.prototype.serialize = function() {\n  return serializeObject.instance(\n    this\n  , this.source\n  , this.blockType\n  , this.isEnd\n  , this.as\n  , this.keyAs\n  , this.unescaped\n  , this.bindType\n  , this.valueType\n  );\n};\n\nfunction Expression(meta) {\n  this.meta = meta;\n}\nExpression.prototype.module = 'expressions';\nExpression.prototype.type = 'Expression';\nExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.meta);\n};\nExpression.prototype.toString = function() {\n  return this.meta && this.meta.source;\n};\nExpression.prototype.truthy = function(context) {\n  var blockType = this.meta.blockType;\n  if (blockType === 'else') return true;\n  var value = this.get(context, true);\n  var truthy = templateTruthy(value);\n  return (blockType === 'unless') ? !truthy : truthy;\n};\nExpression.prototype.get = function() {};\n// Return the expression's segment list with context objects\nExpression.prototype.resolve = function() {};\n// Return a list of segment lists or null\nExpression.prototype.dependencies = function() {};\n// Return the pathSegments that the expression currently resolves to or null\nExpression.prototype.pathSegments = function(context) {\n  var segments = this.resolve(context);\n  return segments && pathSegments(segments);\n};\nExpression.prototype.set = function(context, value) {\n  var segments = this.pathSegments(context);\n  if (!segments) throw new Error('Expression does not support setting');\n  context.controller.model._set(segments, value);\n};\nExpression.prototype._getPatch = function(context, value) {\n  if (this.meta && this.meta.blockType) {\n    value = renderTemplate(value, context);\n  }\n  return (context && context.expression === this && context.item != null) ?\n    value && value[context.item] : value;\n};\nExpression.prototype._resolvePatch = function(context, segments) {\n  return (context && context.expression === this && context.item != null) ?\n    segments.concat(context) : segments;\n};\nExpression.prototype.isUnbound = function(context) {\n  // If the template being rendered has an explicit bindType keyword, such as:\n  // {{unbound #item.text}}\n  var bindType = this.meta && this.meta.bindType;\n  if (bindType === 'unbound') return true;\n  if (bindType === 'bound') return false;\n  // Otherwise, inherit from the context\n  return context.unbound;\n};\n\n\nfunction LiteralExpression(value, meta) {\n  this.value = value;\n  this.meta = meta;\n}\nLiteralExpression.prototype = new Expression();\nLiteralExpression.prototype.type = 'LiteralExpression';\nLiteralExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.value, this.meta);\n};\nLiteralExpression.prototype.get = function(context) {\n  return this._getPatch(context, this.value);\n};\n\nfunction PathExpression(segments, meta) {\n  this.segments = segments;\n  this.meta = meta;\n}\nPathExpression.prototype = new Expression();\nPathExpression.prototype.type = 'PathExpression';\nPathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.meta);\n};\nPathExpression.prototype.get = function(context) {\n  var value = lookup(this.segments, context.controller.model.data);\n  return this._getPatch(context, value);\n};\nPathExpression.prototype.resolve = function(context) {\n  var segments = concat(context.controller._scope, this.segments);\n  return this._resolvePatch(context, segments);\n};\nPathExpression.prototype.dependencies = function(context, forInnerPath) {\n  return outerDependency(this, context, forInnerPath);\n};\n\nfunction RelativePathExpression(segments, meta) {\n  this.segments = segments;\n  this.meta = meta;\n}\nRelativePathExpression.prototype = new Expression();\nRelativePathExpression.prototype.type = 'RelativePathExpression';\nRelativePathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.meta);\n};\nRelativePathExpression.prototype.get = function(context) {\n  var relativeContext = context.forRelative(this);\n  var value = relativeContext.get();\n  if (this.segments.length) {\n    value = renderTemplate(value, relativeContext);\n    value = lookup(this.segments, value);\n  }\n  return this._getPatch(context, value);\n};\nRelativePathExpression.prototype.resolve = function(context) {\n  var relativeContext = context.forRelative(this);\n  var base = (relativeContext.expression) ?\n    relativeContext.expression.resolve(relativeContext) :\n    [];\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nRelativePathExpression.prototype.dependencies = function(context, forInnerPath) {\n  // Return inner dependencies from our ancestor\n  // (e.g., {{ with foo[bar] }} ... {{ this.x }} has 'bar' as a dependency.)\n  var relativeContext = context.forRelative(this);\n  var inner = relativeContext.expression &&\n    relativeContext.expression.dependencies(relativeContext, true);\n  var outer = outerDependency(this, context, forInnerPath);\n  return concat(outer, inner);\n};\n\nfunction AliasPathExpression(alias, segments, meta) {\n  this.alias = alias;\n  this.segments = segments;\n  this.meta = meta;\n}\nAliasPathExpression.prototype = new Expression();\nAliasPathExpression.prototype.type = 'AliasPathExpression';\nAliasPathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.alias, this.segments, this.meta);\n};\nAliasPathExpression.prototype.get = function(context) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) {\n    return aliasContext.item;\n  }\n  var value = aliasContext.get();\n  if (this.segments.length) {\n    value = renderTemplate(value, aliasContext);\n    value = lookup(this.segments, value);\n  }\n  return this._getPatch(context, value);\n};\nAliasPathExpression.prototype.resolve = function(context) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) return;\n  var base = aliasContext.expression.resolve(aliasContext);\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nAliasPathExpression.prototype.dependencies = function(context, forInnerPath) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) {\n    // For keyAliases, use a dependency of the entire list, so that it will\n    // always update when the list changes in any way. This is over-binding,\n    // but would otherwise be much more complex\n    var base = aliasContext.expression.resolve(aliasContext.parent);\n    return [base];\n  }\n  var inner = aliasContext.expression.dependencies(aliasContext, true);\n  var outer = outerDependency(this, context, forInnerPath);\n  return concat(outer, inner);\n};\n\nfunction AttributePathExpression(attribute, segments, meta) {\n  this.attribute = attribute;\n  this.segments = segments;\n  this.meta = meta;\n}\nAttributePathExpression.prototype = new Expression();\nAttributePathExpression.prototype.type = 'AttributePathExpression';\nAttributePathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.attribute, this.segments, this.meta);\n};\nAttributePathExpression.prototype.get = function(context) {\n  var attributeContext = context.forAttribute(this.attribute);\n  if (!attributeContext) return;\n  var value = attributeContext.attributes[this.attribute];\n  if (this.segments.length) {\n    value = renderTemplate(value, attributeContext);\n    value = lookup(this.segments, value);\n  }\n  return this._getPatch(context, value);\n};\nAttributePathExpression.prototype.resolve = function(context) {\n  var attributeContext = context.forAttribute(this.attribute);\n  // Attributes are either a ParentWrapper or a literal value\n  var value = attributeContext && attributeContext.attributes[this.attribute];\n  var base = value && (typeof value.resolve === 'function') &&\n    value.resolve(attributeContext);\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nAttributePathExpression.prototype.dependencies = function(context, forInnerPath) {\n  var attributeContext = context.forAttribute(this.attribute);\n  // Attributes are either a ParentWrapper or a literal value\n  var value = attributeContext && attributeContext.attributes[this.attribute];\n  var inner = value && (typeof value.dependencies === 'function') &&\n    value.dependencies(attributeContext, true);\n  var outer = outerDependency(this, context, forInnerPath);\n  return concat(outer, inner);\n};\n\nfunction BracketsExpression(before, inside, afterSegments, meta) {\n  this.before = before;\n  this.inside = inside;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nBracketsExpression.prototype = new Expression();\nBracketsExpression.prototype.type = 'BracketsExpression';\nBracketsExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.before, this.inside, this.afterSegments, this.meta);\n};\nBracketsExpression.prototype.get = function(context) {\n  var inside = this.inside.get(context);\n  if (inside == null) return;\n  var before = this.before.get(context);\n  if (!before) return;\n  var base = before[inside];\n  var value = (this.afterSegments) ? lookup(this.afterSegments, base) : base;\n  return this._getPatch(context, value);\n};\nBracketsExpression.prototype.resolve = function(context) {\n  // Get and split the current value of the expression inside the brackets\n  var inside = this.inside.get(context);\n  if (inside == null) return;\n\n  // Concat the before, inside, and optional after segments\n  var base = this.before.resolve(context);\n  if (!base) return;\n  var segments = (this.afterSegments) ?\n    base.concat(inside, this.afterSegments) :\n    base.concat(inside);\n  return this._resolvePatch(context, segments);\n};\nBracketsExpression.prototype.dependencies = function(context, forInnerPath) {\n  var before = this.before.dependencies(context, true);\n  var inner = this.inside.dependencies(context);\n  var outer = outerDependency(this, context, forInnerPath);\n  return concat(concat(outer, inner), before);\n};\n\nfunction FnExpression(segments, args, afterSegments, meta) {\n  this.segments = segments;\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n  var parentSegments = segments && segments.slice();\n  this.lastSegment = parentSegments && parentSegments.pop();\n  this.parentSegments = (parentSegments && parentSegments.length) ? parentSegments : null;\n}\nFnExpression.prototype = new Expression();\nFnExpression.prototype.type = 'FnExpression';\nFnExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.args, this.afterSegments, this.meta);\n};\nFnExpression.prototype.get = function(context) {\n  var value = this.apply(context);\n  // Lookup property underneath computed value if needed\n  if (this.afterSegments) {\n    value = lookup(this.afterSegments, value);\n  }\n  return this._getPatch(context, value);\n};\nFnExpression.prototype.apply = function(context, extraInputs) {\n  var parent = this._lookupParent(context);\n  var fn = parent[this.lastSegment];\n  var getFn = fn.get || fn;\n  var out = this._applyFn(getFn, context, extraInputs, parent);\n  return out;\n};\nFnExpression.prototype._lookupParent = function(context) {\n  // Lookup function on current controller\n  var controller = context.controller;\n  var segments = this.parentSegments;\n  var parent = (segments) ? lookup(segments, controller) : controller;\n  if (parent && parent[this.lastSegment]) return parent;\n  // Otherwise lookup function on page\n  var page = controller.page;\n  if (controller !== page) {\n    parent = (segments) ? lookup(segments, page) : page;\n    if (parent && parent[this.lastSegment]) return parent;\n  }\n  // Otherwise lookup function on global\n  parent = (segments) ? lookup(segments, global) : global;\n  if (parent && parent[this.lastSegment]) return parent;\n  // Throw if not found\n  throw new Error('Function not found for: ' + this.segments.join('.'));\n};\nFnExpression.prototype._getInputs = function(context) {\n  var inputs = [];\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var value = this.args[i].get(context);\n    inputs.push(renderValue(value, context));\n  }\n  return inputs;\n};\nFnExpression.prototype._applyFn = function(fn, context, extraInputs, thisArg) {\n  // Apply if there are no path inputs\n  if (!this.args) {\n    return (extraInputs) ?\n      fn.apply(thisArg, extraInputs) :\n      fn.call(thisArg);\n  }\n  // Otherwise, get the current value for path inputs and apply\n  var inputs = this._getInputs(context);\n  if (extraInputs) {\n    for (var i = 0, len = extraInputs.length; i < len; i++) {\n      inputs.push(extraInputs[i]);\n    }\n  }\n  return fn.apply(thisArg, inputs);\n};\nFnExpression.prototype.dependencies = function(context) {\n  var dependencies = [];\n  if (!this.args) return dependencies;\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var argDependencies = this.args[i].dependencies(context);\n    var firstDependency = argDependencies && argDependencies[0];\n    if (!firstDependency) continue;\n    if (firstDependency[firstDependency.length - 1] !== '*') {\n      argDependencies[0] = argDependencies[0].concat('*');\n    }\n    for (var j = 0, jLen = argDependencies.length; j < jLen; j++) {\n      dependencies.push(argDependencies[j]);\n    }\n  }\n  return dependencies;\n};\nFnExpression.prototype.set = function(context, value) {\n  var controller = context.controller;\n  var fn, parent;\n  while (controller) {\n    parent = (this.parentSegments) ?\n      lookup(this.parentSegments, controller) :\n      controller;\n    fn = parent && parent[this.lastSegment];\n    if (fn) break;\n    controller = controller.parent;\n  }\n  var setFn = fn && fn.set;\n  if (!setFn) throw new Error('No setter function for: ' + this.segments.join('.'));\n  var inputs = this._getInputs(context);\n  inputs.unshift(value);\n  var out = setFn.apply(parent, inputs);\n  for (var i in out) {\n    this.args[i].set(context, out[i]);\n  }\n};\n\nfunction NewExpression(segments, args, afterSegments, meta) {\n  FnExpression.call(this, segments, args, afterSegments, meta);\n}\nNewExpression.prototype = new FnExpression();\nNewExpression.prototype.type = 'NewExpression';\nNewExpression.prototype._applyFn = function(Fn, context) {\n  // Apply if there are no path inputs\n  if (!this.args) return new Fn();\n  // Otherwise, get the current value for path inputs and apply\n  var inputs = this._getInputs(context);\n  inputs.unshift(null);\n  return new (Fn.bind.apply(Fn, inputs))();\n};\n\nfunction OperatorExpression(name, args, afterSegments, meta) {\n  this.name = name;\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n  this.getFn = operatorFns.get[name];\n  this.setFn = operatorFns.set[name];\n}\nOperatorExpression.prototype = new FnExpression();\nOperatorExpression.prototype.type = 'OperatorExpression';\nOperatorExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.args, this.afterSegments, this.meta);\n};\nOperatorExpression.prototype.apply = function(context) {\n  var inputs = this._getInputs(context);\n  return this.getFn.apply(null, inputs);\n};\nOperatorExpression.prototype.set = function(context, value) {\n  var inputs = this._getInputs(context);\n  inputs.unshift(value);\n  var out = this.setFn.apply(null, inputs);\n  for (var i in out) {\n    this.args[i].set(context, out[i]);\n  }\n};\n\nfunction SequenceExpression(args, afterSegments, meta) {\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nSequenceExpression.prototype = new OperatorExpression();\nSequenceExpression.prototype.type = 'SequenceExpression';\nSequenceExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.args, this.afterSegments, this.meta);\n};\nSequenceExpression.prototype.name = ',';\nSequenceExpression.prototype.getFn = operatorFns.get[','];\nSequenceExpression.prototype.resolve = function(context) {\n  var last = this.args[this.args.length - 1];\n  return last.resolve(context);\n};\nSequenceExpression.prototype.dependencies = function(context, forInnerPath) {\n  var dependencies = [];\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var argDependencies = this.args[i].dependencies(context, forInnerPath);\n    for (var j = 0, jLen = argDependencies.length; j < jLen; j++) {\n      dependencies.push(argDependencies[j]);\n    }\n  }\n  return dependencies;\n};\n\nfunction ScopedModelExpression(expression, meta) {\n  this.expression = expression;\n  this.meta = meta;\n}\nScopedModelExpression.prototype = new Expression();\nScopedModelExpression.prototype.type = 'ScopedModelExpression';\nScopedModelExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.meta);\n};\n// Return a scoped model instead of the value\nScopedModelExpression.prototype.get = function(context) {\n  var segments = this.pathSegments(context);\n  if (!segments) return;\n  return context.controller.model.scope(segments.join('.'));\n};\n// Delegate other methods to the inner expression\nScopedModelExpression.prototype.resolve = function(context) {\n  return this.expression.resolve(context);\n};\nScopedModelExpression.prototype.dependencies = function(context, forInnerPath) {\n  return this.expression.dependencies(context, forInnerPath);\n};\nScopedModelExpression.prototype.pathSegments = function(context) {\n  return this.expression.pathSegments(context);\n};\nScopedModelExpression.prototype.set = function(context, value) {\n  return this.expression.set(context, value);\n};\n\nfunction outerDependency(expression, context, forInnerPath) {\n  if (forInnerPath) return;\n  var val = expression.resolve(context);\n  if (typeof val === 'undefined') return;\n  return [val];\n}\n\nfunction concat(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a.concat(b);\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby-templates/lib/operatorFns.js":"// `-` and `+` can be either unary or binary, so all unary operators are\n// postfixed with `U` to differentiate\n\nexports.get = {\n  // Unary operators\n  '!U': function(value) {\n    return !value;\n  }\n, '-U': function(value) {\n    return -value;\n  }\n, '+U': function(value) {\n    return +value;\n  }\n, '~U': function(value) {\n    return ~value;\n  }\n, 'typeofU': function(value) {\n    return typeof value;\n  }\n  // Binary operators\n, '||': function(left, right) {\n    return left || right;\n  }\n, '&&': function(left, right) {\n    return left && right;\n  }\n, '|': function(left, right) {\n    return left | right;\n  }\n, '^': function(left, right) {\n    return left ^ right;\n  }\n, '&': function(left, right) {\n    return left & right;\n  }\n, '==': function(left, right) {\n    return left == right; // jshint ignore:line\n  }\n, '!=': function(left, right) {\n    return left != right; // jshint ignore:line\n  }\n, '===': function(left, right) {\n    return left === right;\n  }\n, '!==': function(left, right) {\n    return left !== right;\n  }\n, '<': function(left, right) {\n    return left < right;\n  }\n, '>': function(left, right) {\n    return left > right;\n  }\n, '<=': function(left, right) {\n    return left <= right;\n  }\n, '>=': function(left, right) {\n    return left >= right;\n  }\n, 'instanceof': function(left, right) {\n    return left instanceof right;\n  }\n, 'in': function(left, right) {\n    return left in right;\n  }\n, '<<': function(left, right) {\n    return left << right;\n  }\n, '>>': function(left, right) {\n    return left >> right;\n  }\n, '>>>': function(left, right) {\n    return left >>> right;\n  }\n, '+': function(left, right) {\n    return left + right;\n  }\n, '-': function(left, right) {\n    return left - right;\n  }\n, '*': function(left, right) {\n    return left * right;\n  }\n, '/': function(left, right) {\n    return left / right;\n  }\n, '%': function(left, right) {\n    return left % right;\n  }\n  // Conditional operator\n, '?': function(test, consequent, alternate) {\n    return (test) ? consequent : alternate;\n  }\n, // Sequence\n  ',': function() {\n    return arguments[arguments.length - 1];\n  }\n  // Array literal\n, '[]': function() {\n    return Array.prototype.slice.call(arguments);\n  }\n  // Object literal\n, '{}': function() {\n    var value = {};\n    for (var i = 0, len = arguments.length; i < len; i += 2) {\n      var key = arguments[i];\n      value[key] = arguments[i + 1];\n    }\n    return value;\n  }\n};\n\nexports.set = {\n  // Unary operators\n  '!U': function(value) {\n    return [!value];\n  }\n, '-U': function(value) {\n    return [-value];\n  }\n  // Binary operators\n, '==': function(value, left, right) {\n    if (value) return [right];\n  }\n, '===': function(value, left, right) {\n    if (value) return [right];\n  }\n, 'in': function(value, left, right) {\n    right[left] = true;\n    return {1: right};\n  }\n, '+': function(value, left, right) {\n    return [value - right];\n  }\n, '-': function(value, left, right) {\n    return [value + right];\n  }\n, '*': function(value, left, right) {\n    return [value / right];\n  }\n, '/': function(value, left, right) {\n    return [value * right];\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby-templates/lib/templates.js":"var saddle = require('saddle');\nvar serializeObject = require('serialize-object');\n\n(function() {\n  for (var key in saddle) {\n    exports[key] = saddle[key];\n  }\n})();\n\nexports.Marker = Marker;\nexports.View = View;\nexports.ViewInstance = ViewInstance;\nexports.DynamicViewInstance = DynamicViewInstance;\nexports.ParentWrapper = ParentWrapper;\n\nexports.Views = Views;\n\nexports.MarkupHook = MarkupHook;\nexports.ElementOn = ElementOn;\nexports.ComponentOn = ComponentOn;\nexports.AsProperty = AsProperty;\nexports.AsObject = AsObject;\nexports.AsObjectComponent = AsObjectComponent;\nexports.AsArray = AsArray;\nexports.AsArrayComponent = AsArrayComponent;\n\nexports.emptyTemplate = new saddle.Template([]);\n\n// Add ::isUnbound to Template && Binding\nsaddle.Template.prototype.isUnbound = function(context) {\n  return context.unbound;\n};\nsaddle.Binding.prototype.isUnbound = function() {\n  return this.template.expression.isUnbound(this.context);\n};\n\n// Add Template::resolve\nsaddle.Template.prototype.resolve = function() {};\n\n// The Template::dependencies method is specific to how Derby bindings work,\n// so extend all of the Saddle Template types here\nsaddle.Template.prototype.dependencies = function(context) {\n  return getArrayDependencies(this.content, context);\n};\nsaddle.Doctype.prototype.dependencies = function() {};\nsaddle.Text.prototype.dependencies = function() {};\nsaddle.DynamicText.prototype.dependencies = function(context) {\n  return getDependencies(this.expression, context);\n};\nsaddle.Comment.prototype.dependencies = function() {};\nsaddle.DynamicComment.prototype.dependencies = function(context) {\n  return getDependencies(this.expression, context);\n};\nsaddle.Element.prototype.dependencies = function(context) {\n  var items = getMapDependencies(this.attributes, context);\n  return getArrayDependencies(this.content, context, items);\n};\nsaddle.Block.prototype.dependencies = function(context) {\n  var items = getDependencies(this.expression, context);\n  return getArrayDependencies(this.content, context, items);\n};\nsaddle.ConditionalBlock.prototype.dependencies = function(context) {\n  var items = getArrayDependencies(this.expressions, context);\n  return getArrayOfArrayDependencies(this.contents, context, items);\n};\nsaddle.EachBlock.prototype.dependencies = function(context) {\n  var items = getDependencies(this.expression, context);\n  items = getArrayDependencies(this.content, context, items);\n  return getArrayDependencies(this.elseContent, context, items);\n};\nsaddle.Attribute.prototype.dependencies = function() {};\nsaddle.DynamicAttribute.prototype.dependencies = function(context) {\n  return getDependencies(this.expression, context);\n};\n\nfunction getArrayOfArrayDependencies(expressions, context, items) {\n  if (!expressions) return items;\n  for (var i = 0, len = expressions.length; i < len; i++) {\n    items = getArrayDependencies(expressions[i], context, items);\n  }\n  return items;\n}\nfunction getArrayDependencies(expressions, context, items) {\n  if (!expressions) return items;\n  for (var i = 0, len = expressions.length; i < len; i++) {\n    items = getDependencies(expressions[i], context, items);\n  }\n  return items;\n}\nfunction getMapDependencies(expressions, context, items) {\n  if (!expressions) return items;\n  for (var key in expressions) {\n    items = getDependencies(expressions[key], context, items);\n  }\n  return items;\n}\nfunction getDependencies(expression, context, items) {\n  var dependencies = expression && expression.dependencies(context);\n  if (!dependencies) return items;\n  for (var i = 0, len = dependencies.length; i < len; i++) {\n    items || (items = []);\n    items.push(dependencies[i]);\n  }\n  return items;\n}\n\nvar markerHooks = [{\n  emit: function(context, node) {\n    node.$component = context.controller;\n    context.controller.markerNode = node;\n  }\n}];\nfunction Marker(data) {\n  saddle.Comment.call(this, data, markerHooks);\n}\nMarker.prototype = Object.create(saddle.Comment.prototype);\nMarker.prototype.type = 'Marker';\nMarker.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data);\n};\nMarker.prototype.get = function() {\n  return '';\n};\n\nfunction ViewAttributesMap(source) {\n  var items = source.split(/\\s+/);\n  for (var i = 0, len = items.length; i < len; i++) {\n    this[items[i]] = true;\n  }\n}\nfunction ViewArraysMap(source) {\n  var items = source.split(/\\s+/);\n  for (var i = 0, len = items.length; i < len; i++) {\n    var item = items[i].split('/');\n    this[item[0]] = item[1] || item[0];\n  }\n}\nfunction View(views, name, source, options) {\n  this.views = views;\n  this.name = name;\n  this.source = source;\n  this.options = options;\n\n  var nameSegments = (this.name || '').split(':');\n  var lastSegment = nameSegments.pop();\n  this.namespace = nameSegments.join(':');\n  this.registeredName = (lastSegment === 'index') ? this.namespace : this.name;\n\n  this.attributesMap = options && options.attributes &&\n    new ViewAttributesMap(options.attributes);\n  this.arraysMap = options && options.arrays &&\n    new ViewArraysMap(options.arrays);\n  // The empty string is considered true for easier HTML attribute parsing\n  this.unminified = options && (options.unminified || options.unminified === '');\n  this.string = options && (options.string || options.string === '');\n  this.literal = options && (options.literal || options.literal === '');\n  this.template = null;\n  this.componentFactory = null;\n}\nView.prototype = Object.create(saddle.Template.prototype);\nView.prototype.type = 'View';\nView.prototype.serialize = function() {\n  return null;\n};\nView.prototype._isComponent = function(context) {\n  if (!this.componentFactory) return false;\n  if (context.attributes && context.attributes.extend) return false;\n  return true;\n};\nView.prototype._initComponent = function(context) {\n  return (this._isComponent(context)) ?\n    this.componentFactory.init(context) : context;\n};\nView.prototype._queueCreate = function(context, viewContext) {\n  if (this._isComponent(context)) {\n    var componentFactory = this.componentFactory;\n    context.queue(function queuedCreate() {\n      componentFactory.create(viewContext);\n    });\n\n    if (!context.hooks) return;\n    context.queue(function queuedComponentHooks() {\n      // Kick off hooks if view instance specified `on` or `as` attributes\n      for (var i = 0, len = context.hooks.length; i < len; i++) {\n        context.hooks[i].emit(context, viewContext.controller);\n      }\n    });\n  }\n};\nView.prototype.get = function(context, unescaped) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  return template.get(viewContext, unescaped);\n};\nView.prototype.getFragment = function(context, binding) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  var fragment = template.getFragment(viewContext, binding);\n  this._queueCreate(context, viewContext);\n  return fragment;\n};\nView.prototype.appendTo = function(parent, context) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  template.appendTo(parent, viewContext);\n  this._queueCreate(context, viewContext);\n};\nView.prototype.attachTo = function(parent, node, context) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  var node = template.attachTo(parent, node, viewContext);\n  this._queueCreate(context, viewContext);\n  return node;\n};\nView.prototype.dependencies = function(context) {\n  var template = this.template || this.parse();\n  return template.dependencies(context);\n};\nView.prototype.parse = function() {\n  this._parse();\n  if (this.componentFactory) {\n    var marker = new Marker(this.name);\n    this.template.content.unshift(marker);\n  }\n  return this.template;\n};\n// View.prototype._parse is defined in parsing.js, so that it doesn't have to\n// be included in the client if templates are all parsed server-side\nView.prototype._parse = function() {\n  throw new Error('View parsing not available');\n};\n\nfunction ViewInstance(name, attributes, hooks, initHooks) {\n  this.name = name;\n  this.attributes = attributes;\n  this.hooks = hooks;\n  this.initHooks = initHooks;\n  this.view = null;\n}\nViewInstance.prototype = Object.create(saddle.Template.prototype);\nViewInstance.prototype.type = 'ViewInstance';\nViewInstance.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.attributes, this.hooks, this.initHooks);\n};\nViewInstance.prototype.get = function(context, unescaped) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.get(viewContext, unescaped);\n};\nViewInstance.prototype.getFragment = function(context, binding) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.getFragment(viewContext, binding);\n};\nViewInstance.prototype.appendTo = function(parent, context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  view.appendTo(parent, viewContext);\n};\nViewInstance.prototype.attachTo = function(parent, node, context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.attachTo(parent, node, viewContext);\n};\nViewInstance.prototype.dependencies = function(context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.dependencies(viewContext);\n};\nViewInstance.prototype._find = function(context) {\n  if (this.view) return this.view;\n  var contextView = context.getView();\n  var namespace = contextView && contextView.namespace;\n  this.view = context.meta.views.find(this.name, namespace);\n  if (!this.view) {\n    var message = context.meta.views.findErrorMessage(this.name, contextView);\n    throw new Error(message);\n  }\n  return this.view;\n};\n\nfunction DynamicViewInstance(nameExpression, attributes, hooks, initHooks) {\n  this.nameExpression = nameExpression;\n  this.attributes = attributes;\n  this.hooks = hooks;\n  this.initHooks = initHooks;\n}\nDynamicViewInstance.prototype = Object.create(ViewInstance.prototype);\nDynamicViewInstance.prototype.type = 'DynamicViewInstance';\nDynamicViewInstance.prototype.serialize = function() {\n  return serializeObject.instance(this, this.nameExpression, this.attributes, this.hooks, this.initHooks);\n};\nDynamicViewInstance.prototype._find = function(context) {\n  var name = this.nameExpression.get(context);\n  var contextView = context.getView();\n  var namespace = contextView && contextView.namespace;\n  var view = name && context.meta.views.find(name, namespace);\n  return view || exports.emptyTemplate;\n};\n\nfunction ParentWrapper(template, expression) {\n  this.template = template;\n  this.expression = expression;\n}\nParentWrapper.prototype = Object.create(saddle.Template.prototype);\nParentWrapper.prototype.type = 'ParentWrapper';\nParentWrapper.prototype.serialize = function() {\n  return serializeObject.instance(this, this.template, this.expression);\n};\nParentWrapper.prototype.get = function(context, unescaped) {\n  return (this.expression || this.template).get(context.forViewParent(), unescaped);\n};\nParentWrapper.prototype.getFragment = function(context, binding) {\n  return this.template.getFragment(context.forViewParent(), binding);\n};\nParentWrapper.prototype.appendTo = function(parent, context) {\n  this.template.appendTo(parent, context.forViewParent());\n};\nParentWrapper.prototype.attachTo = function(parent, node, context) {\n  return this.template.attachTo(parent, node, context.forViewParent());\n};\nParentWrapper.prototype.resolve = function(context) {\n  return this.expression && this.expression.resolve(context.forViewParent());\n};\nParentWrapper.prototype.dependencies = function(context, forInnerPath) {\n  return (this.expression || this.template).dependencies(context.forViewParent(), forInnerPath);\n};\n\nfunction ViewsMap() {}\nfunction Views() {\n  this.nameMap = new ViewsMap();\n  this.tagMap = new ViewsMap();\n  // TODO: elementMap is deprecated and should be removed with Derby 0.6.0\n  this.elementMap = this.tagMap;\n}\nViews.prototype.find = function(name, namespace) {\n  var map = this.nameMap;\n\n  // Exact match lookup\n  var exactName = (namespace) ? namespace + ':' + name : name;\n  var match = map[exactName];\n  if (match) return match;\n\n  // Relative lookup\n  var segments = name.split(':');\n  var segmentsDepth = segments.length;\n  if (namespace) segments = namespace.split(':').concat(segments);\n  // Iterate through segments, leaving the `segmentsDepth` segments and\n  // removing the second to `segmentsDepth` segment to traverse up the\n  // namespaces. Decrease `segmentsDepth` if not found and repeat again.\n  while (segmentsDepth > 0) {\n    var testSegments = segments.slice();\n    while (testSegments.length > segmentsDepth) {\n      testSegments.splice(-1 - segmentsDepth, 1);\n      var testName = testSegments.join(':');\n      var match = map[testName];\n      if (match) return match;\n    }\n    segmentsDepth--;\n  }\n};\nViews.prototype.register = function(name, source, options) {\n  var mapName = name.replace(/:index$/, '');\n  var view = this.nameMap[mapName];\n  if (view) {\n    // Recreate the view if it already exists. We re-apply the constructor\n    // instead of creating a new view object so that references to object\n    // can be cached after finding the first time\n    var componentFactory = view.componentFactory;\n    View.call(view, this, name, source, options);\n    view.componentFactory = componentFactory;\n  } else {\n    view = new View(this, name, source, options);\n  }\n  this.nameMap[mapName] = view;\n  // TODO: element is deprecated and should be removed with Derby 0.6.0\n  var tagName = options && (options.tag || options.element);\n  if (tagName) this.tagMap[tagName] = view;\n  return view;\n};\nViews.prototype.serialize = function(options) {\n  var out = 'function(derbyTemplates, views) {' +\n    'var expressions = derbyTemplates.expressions;' +\n    'var templates = derbyTemplates.templates;';\n  var forServer = options && options.server;\n  var minify = options && options.minify;\n  for (var name in this.nameMap) {\n    var view = this.nameMap[name];\n    var template = view.template || view.parse();\n    if (!forServer && view.options) {\n      // Do not serialize views with the `serverOnly` option, except when\n      // serializing for a server script\n      if (view.options.serverOnly) continue;\n      // For views with the `server` option, serialize them with a blank\n      // template body. This allows them to be used from other views on the\n      // browser, but they will output nothing on the browser\n      if (view.options.server) template = exports.emptyTemplate;\n    }\n    out += 'views.register(' + serializeObject.args([\n      view.name\n    , (minify) ? null : view.source\n    , (hasKeys(view.options)) ? view.options : null\n    ]) + ').parse = function() {return this.template = ' + template.serialize() + '};';\n  }\n  return out + '}';\n};\nViews.prototype.findErrorMessage = function(name, contextView) {\n  var names = Object.keys(this.nameMap);\n  var message = 'Cannot find view \"' + name + '\" in' +\n    [''].concat(names).join('\\n  ') + '\\n';\n  if (contextView) {\n    message += '\\nWithin template \"' + contextView.name + '\":\\n' + contextView.source;\n  }\n  return message;\n};\n\n\nfunction MarkupHook() {}\nMarkupHook.prototype.module = saddle.Template.prototype.module;\n\nfunction ElementOn(name, expression) {\n  this.name = name;\n  this.expression = expression;\n}\nElementOn.prototype = Object.create(MarkupHook.prototype);\nElementOn.prototype.type = 'ElementOn';\nElementOn.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.expression);\n};\nElementOn.prototype.emit = function(context, element) {\n  var elementOn = this;\n  if (this.name === 'create') {\n    this.apply(context, element);\n\n  } else if (this.name === 'destroy') {\n    var destroyListeners = element.$destroyListeners || (element.$destroyListeners = []);\n    destroyListeners.push(function elementOnDestroy() {\n      elementOn.apply(context, element);\n    });\n\n  } else {\n    element.addEventListener(this.name, function elementOnListener(event) {\n      return elementOn.apply(context, element, event);\n    }, false);\n  }\n};\nElementOn.prototype.apply = function(context, element, event) {\n  var modelData = context.controller.model.data;\n  modelData.$event = event;\n  modelData.$element = element;\n  var out = this.expression.apply(context);\n  delete modelData.$event;\n  delete modelData.$element;\n  return out;\n};\n\nfunction ComponentOn(name, expression) {\n  this.name = name;\n  this.expression = expression;\n}\nComponentOn.prototype = Object.create(MarkupHook.prototype);\nComponentOn.prototype.type = 'ComponentOn';\nComponentOn.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.expression);\n};\nComponentOn.prototype.emit = function(context, component) {\n  var expression = this.expression;\n  component.on(this.name, function componentOnListener() {\n    var args = arguments.length && Array.prototype.slice.call(arguments);\n    return expression.apply(context, args);\n  });\n};\n\nfunction AsProperty(segments) {\n  this.segments = segments;\n  this.lastSegment = segments.pop();\n}\nAsProperty.prototype = Object.create(MarkupHook.prototype);\nAsProperty.prototype.type = 'AsProperty';\nAsProperty.prototype.serialize = function() {\n  var segments = this.segments.concat(this.lastSegment);\n  return serializeObject.instance(this, segments);\n};\nAsProperty.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  node[this.lastSegment] = target;\n};\n\nfunction AsObject(segments, keyExpression) {\n  AsProperty.call(this, segments);\n  this.keyExpression = keyExpression;\n}\nAsObject.prototype = Object.create(AsProperty.prototype);\nAsObject.prototype.type = 'AsObject';\nAsObject.prototype.serialize = function() {\n  var segments = this.segments.concat(this.lastSegment);\n  return serializeObject.instance(this, segments, this.keyExpression);\n};\nAsObject.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  var object = node[this.lastSegment] || (node[this.lastSegment] = {});\n  var key = this.keyExpression.get(context);\n  object[key] = target;\n  this.addListeners(target, object, key);\n};\nAsObject.prototype.addListeners = function(target, object, key) {\n  this.addDestroyListener(target, function asObjectDestroy() {\n    delete object[key];\n  });\n};\nAsObject.prototype.addDestroyListener = function(target, listener) {\n  var listeners = target.$destroyListeners || (target.$destroyListeners = []);\n  listeners.push(listener);\n};\n\nfunction AsObjectComponent(segments, keyExpression) {\n  AsObject.call(this, segments, keyExpression);\n}\nAsObjectComponent.prototype = Object.create(AsObject.prototype);\nAsObjectComponent.prototype.type = 'AsObjectComponent';\nAsObjectComponent.prototype.addDestroyListener = function(target, listener) {\n  target.on('destroy', listener);\n};\n\nfunction AsArray(segments) {\n  AsProperty.call(this, segments);\n}\nAsArray.prototype = Object.create(AsProperty.prototype);\nAsArray.prototype.type = 'AsArray';\nAsArray.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  var array = node[this.lastSegment] || (node[this.lastSegment] = []);\n\n  // Iterate backwards, since rendering will usually append\n  for (var i = array.length; i--;) {\n    var item = array[i];\n    // Don't add an item if already in the array\n    if (item === target) return;\n    var mask = this.comparePosition(target, item);\n    // If the emitted target is after the current item in the document,\n    // insert it next in the array\n    // Node.DOCUMENT_POSITION_FOLLOWING = 4\n    if (mask & 4) {\n      array.splice(i + 1, 0, target);\n      this.addListeners(target, array);\n      return;\n    }\n  }\n  // Add to the beginning if before all items\n  array.unshift(target);\n  this.addListeners(target, array);\n};\nAsArray.prototype.addListeners = function(target, array) {\n  this.addDestroyListener(target, function asArrayDestroy() {\n    var index = array.indexOf(target);\n    if (index !== -1) array.splice(index, 1);\n  });\n};\nAsArray.prototype.comparePosition = function(target, item) {\n  return item.compareDocumentPosition(target);\n};\nAsArray.prototype.addDestroyListener = AsObject.prototype.addDestroyListener;\n\nfunction AsArrayComponent(segments) {\n  AsArray.call(this, segments);\n}\nAsArrayComponent.prototype = Object.create(AsArray.prototype);\nAsArrayComponent.prototype.type = 'AsArrayComponent';\nAsArrayComponent.prototype.comparePosition = function(target, item) {\n  return item.markerNode.compareDocumentPosition(target.markerNode);\n};\nAsArrayComponent.prototype.addDestroyListener = AsObjectComponent.prototype.addDestroyListener;\n\nfunction traverseAndCreate(node, segments) {\n  var len = segments.length;\n  if (!len) return node;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    node = node[segment] || (node[segment] = {});\n  }\n  return node;\n}\n\nfunction hasKeys(value) {\n  if (!value) return false;\n  for (var key in value) {\n    return true;\n  }\n  return false;\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/documentListeners.js":"var textDiff = require('./textDiff');\n\nexports.add = addDocumentListeners;\nexports.inputSupportsSelection = inputSupportsSelection;\n\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#do-not-apply\n// TODO: Date types support\nfunction inputSupportsSelection(input) {\n  var type = input.type;\n  return (\n    type === 'text' ||\n    type === 'textarea' ||\n    type === 'search' ||\n    type === 'url' ||\n    type === 'tel' ||\n    type === 'password'\n  );\n}\nfunction inputIsNumberValue(input) {\n  var type = input.type;\n  return (type === 'number' || (type === 'range' && !input.multiple));\n}\nfunction inputValue(input) {\n  return inputIsNumberValue(input) ? input.valueAsNumber : input.value;\n}\n\nfunction addDocumentListeners(doc) {\n  doc.addEventListener('input', documentInput, true);\n  doc.addEventListener('change', documentChange, true);\n\n  // Listen to more events for versions of IE with buggy input event implementations\n  if (parseFloat(window.navigator.appVersion.split('MSIE ')[1]) <= 9) {\n    // We're listening on selectionchange because there's no other event emitted when\n    // the user clicks 'delete' from a context menu when right clicking on selected text.\n    // So although this event fires overly aggressively, it's the only real way\n    // to ensure that we can detect all changes to the input value in IE <= 9\n    doc.addEventListener('selectionchange', function(e){\n      if (document.activeElement) {\n        documentInput({target: document.activeElement}); // selectionchange evts don't have the e.target we need\n      }\n    }, true);\n  }\n\n  // For some reason valueAsNumber returns NaN for number inputs in IE\n  // until a new IE version that handles this is released, parse input.value as a fallback\n  var input = document.createElement('input');\n  input.type = 'number';\n  input.value = '7';\n  if (input.valueAsNumber !== input.valueAsNumber) {\n    var oldInputValue = inputValue;\n    inputValue = function(input) {\n      if (input.type === 'number') {\n        return inputIsNumberValue(input) ? parseFloat(input.value) : input.value;\n      } else {\n        return oldInputValue.apply(this, arguments);\n      }\n    };\n  }\n}\n\nfunction documentInput(e) {\n  var target = e.target;\n\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {\n    setInputValue(e, target);\n  }\n}\n\nfunction documentChange(e) {\n  var target = e.target;\n\n  if (target.tagName === 'INPUT') {\n    setBoundProperty(target, 'checked');\n    setInputValue(e, target);\n\n  } else if (target.tagName === 'SELECT') {\n    setOptionBindings(target);\n\n  } else if (target.tagName === 'TEXTAREA') {\n    setInputValue(e, target);\n  }\n}\n\nfunction setBoundProperty(node, property) {\n  var binding = node.$bindAttributes && node.$bindAttributes[property];\n  if (!binding || binding.isUnbound()) return;\n\n  var value = node[property];\n  binding.template.expression.set(binding.context, value);\n}\n\nfunction setInputValue(e, target) {\n  var binding = target.$bindAttributes && target.$bindAttributes.value;\n  if (!binding || binding.isUnbound()) return;\n\n  if (inputSupportsSelection(target)) {\n    var pass = {$event: e};\n    textDiffBinding(binding, target.value, pass);\n  } else {\n    var value = inputValue(target);\n    binding.template.expression.set(binding.context, value);\n  }\n}\n\nfunction textDiffBinding(binding, value, pass) {\n  var expression = binding.template.expression;\n  var segments = expression.pathSegments(binding.context);\n  if (segments) {\n    var model = binding.context.controller.model.pass(pass);\n    textDiff.onTextInput(model, segments, value);\n  } else if (expression.set) {\n    expression.set(binding.context, value);\n  }\n}\n\nfunction setOptionBindings(parent) {\n  for (var node = parent.firstChild; node; node = node.nextSibling) {\n    if (node.tagName === 'OPTION') {\n      setBoundProperty(node, 'selected');\n    } else if (node.hasChildNodes()) {\n      setOptionBindings(node);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/textDiff.js":"exports.onStringInsert = onStringInsert;\nexports.onStringRemove = onStringRemove;\nexports.onTextInput = onTextInput;\n\nfunction onStringInsert(el, previous, index, text) {\n  function transformCursor(cursor) {\n    return (index < cursor) ? cursor + text.length : cursor;\n  }\n  previous || (previous = '');\n  var newText = previous.slice(0, index) + text + previous.slice(index);\n  replaceText(el, newText, transformCursor);\n}\n\nfunction onStringRemove(el, previous, index, howMany) {\n  function transformCursor(cursor) {\n    return (index < cursor) ? cursor - Math.min(howMany, cursor - index) : cursor;\n  }\n  previous || (previous = '');\n  var newText = previous.slice(0, index) + previous.slice(index + howMany);\n  replaceText(el, newText, transformCursor);\n}\n\nfunction replaceText(el, newText, transformCursor) {\n  var selectionStart = transformCursor(el.selectionStart);\n  var selectionEnd = transformCursor(el.selectionEnd);\n\n  var scrollTop = el.scrollTop;\n  el.value = newText;\n  if (el.scrollTop !== scrollTop) {\n    el.scrollTop = scrollTop;\n  }\n  if (document.activeElement === el) {\n    el.selectionStart = selectionStart;\n    el.selectionEnd = selectionEnd;\n  }\n}\n\nfunction onTextInput(model, segments, value) {\n  var previous = model._get(segments) || '';\n  if (previous === value) return;\n  var start = 0;\n  while (previous.charAt(start) === value.charAt(start)) {\n    start++;\n  }\n  var end = 0;\n  while (\n    previous.charAt(previous.length - 1 - end) === value.charAt(value.length - 1 - end) &&\n    end + start < previous.length &&\n    end + start < value.length\n  ) {\n    end++;\n  }\n\n  if (previous.length !== start + end) {\n    var howMany = previous.length - start - end;\n    model._stringRemove(segments, start, howMany);\n  }\n  if (value.length !== start + end) {\n    var inserted = value.slice(start, value.length - end);\n    model._stringInsert(segments, start, inserted);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/Page.js":"var derbyTemplates = require('derby-templates');\nvar contexts = derbyTemplates.contexts;\nvar expressions = derbyTemplates.expressions;\nvar templates = derbyTemplates.templates;\nvar util = require('racer/lib/util');\nvar EventModel = require('./eventmodel');\nvar textDiff = require('./textDiff');\nvar Controller = require('./Controller');\nvar documentListeners = require('./documentListeners');\n\nmodule.exports = Page;\n\nfunction Page(app, model, req, res) {\n  Controller.call(this, app, this, model);\n  this.req = req;\n  this.res = res;\n  this.params = null;\n  if (this.init) this.init(model);\n  this.context = this._createContext();\n  this._eventModel = null;\n  this._removeModelListeners = null;\n  this._components = {};\n  this._addListeners();\n}\n\nutil.mergeInto(Page.prototype, Controller.prototype);\n\nPage.prototype.$bodyClass = function(ns) {\n  if (!ns) return;\n  var classNames = [];\n  var segments = ns.split(':');\n  for (var i = 0, len = segments.length; i < len; i++) {\n    var className = segments.slice(0, i + 1).join('-');\n    classNames.push(className);\n  }\n  return classNames.join(' ');\n};\n\nPage.prototype.$preventDefault = function(e) {\n  e.preventDefault();\n};\n\nPage.prototype.$stopPropagation = function(e) {\n  e.stopPropagation();\n};\n\nPage.prototype._setRenderParams = function(ns) {\n  this.model.set('$render.ns', ns);\n  this.model.set('$render.params', this.params);\n  this.model.set('$render.url', this.params && this.params.url);\n  this.model.set('$render.query', this.params && this.params.query);\n};\n\nPage.prototype._setRenderPrefix = function(ns) {\n  var prefix = (ns) ? ns + ':' : '';\n  this.model.set('$render.prefix', prefix);\n};\n\nPage.prototype.get = function(viewName, ns, unescaped) {\n  this._setRenderPrefix(ns);\n  var view = this.getView(viewName, ns);\n  return view.get(this.context, unescaped);\n};\n\nPage.prototype.getFragment = function(viewName, ns) {\n  this._setRenderPrefix(ns);\n  var view = this.getView(viewName, ns);\n  return view.getFragment(this.context);\n};\n\nPage.prototype.getView = function(viewName, ns) {\n  return this.app.views.find(viewName, ns);\n};\n\nPage.prototype.render = function(ns) {\n  this.app.emit('render', this);\n  this.context.pause();\n  this._setRenderParams(ns);\n  var titleFragment = this.getFragment('TitleElement', ns);\n  var bodyFragment = this.getFragment('BodyElement', ns);\n  var titleElement = document.getElementsByTagName('title')[0];\n  titleElement.parentNode.replaceChild(titleFragment, titleElement);\n  document.body.parentNode.replaceChild(bodyFragment, document.body);\n  this.context.unpause();\n  if (this.create) this.create(this.model, this.dom);\n  this.app.emit('routeDone', this, 'render');\n};\n\nPage.prototype.attach = function() {\n  this.context.pause();\n  var ns = this.model.get('$render.ns');\n  var titleView = this.getView('TitleElement', ns);\n  var bodyView = this.getView('BodyElement', ns);\n  var titleElement = document.getElementsByTagName('title')[0];\n  titleView.attachTo(titleElement.parentNode, titleElement, this.context);\n  bodyView.attachTo(document.body.parentNode, document.body, this.context);\n  this.context.unpause();\n  if (this.create) this.create(this.model, this.dom);\n};\n\nPage.prototype._createContext = function() {\n  var contextMeta = new contexts.ContextMeta();\n  contextMeta.views = this.app && this.app.views;\n  var context = new contexts.Context(contextMeta, this);\n  context.expression = new expressions.PathExpression([]);\n  context.alias = '#root';\n  return context;\n};\n\nPage.prototype._addListeners = function() {\n  var eventModel = this._eventModel = new EventModel();\n  this._addModelListeners(eventModel);\n  this._addContextListeners(eventModel);\n};\n\nPage.prototype.destroy = function() {\n  this.emit('destroy');\n  this._removeModelListeners();\n  for (var id in this._components) {\n    var component = this._components[id];\n    component.destroy();\n  }\n  // Remove all data, refs, listeners, and reactive functions\n  // for the previous page\n  var silentModel = this.model.silent();\n  silentModel.destroy('_page');\n  silentModel.destroy('$components');\n  // Unfetch and unsubscribe from all queries and documents\n  silentModel.unloadAll && silentModel.unloadAll();\n};\n\nPage.prototype._addModelListeners = function(eventModel) {\n  var model = this.model;\n  if (!model) return;\n\n  var context = this.context;\n  var changeListener = model.on('change', '**', function onChange(path, value, previous, pass) {\n    var segments = util.castSegments(path.split('.'));\n    // The pass parameter is passed in for special handling of updates\n    // resulting from stringInsert or stringRemove\n    eventModel.set(segments, previous, pass);\n  });\n  var loadListener = model.on('load', '**', function onLoad(path) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.set(segments);\n  });\n  var unloadListener = model.on('unload', '**', function onUnload(path) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.set(segments);\n  });\n  var insertListener = model.on('insert', '**', function onInsert(path, index, values) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.insert(segments, index, values.length);\n  });\n  var removeListener = model.on('remove', '**', function onRemove(path, index, values) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.remove(segments, index, values.length);\n  });\n  var moveListener = model.on('move', '**', function onMove(path, from, to, howMany) {\n    var segments = util.castSegments(path.split('.'));\n    eventModel.move(segments, from, to, howMany);\n  });\n\n  this._removeModelListeners = function() {\n    model.removeListener('change', changeListener);\n    model.removeListener('load', loadListener);\n    model.removeListener('unload', unloadListener);\n    model.removeListener('insert', insertListener);\n    model.removeListener('remove', removeListener);\n    model.removeListener('move', moveListener);\n  };\n};\n\nPage.prototype._addContextListeners = function(eventModel) {\n  this.context.meta.addBinding = addBinding;\n  this.context.meta.removeBinding = removeBinding;\n  this.context.meta.removeNode = removeNode;\n  this.context.meta.addItemContext = addItemContext;\n  this.context.meta.removeItemContext = removeItemContext;\n\n  function addItemContext(context) {\n    var segments = context.expression.resolve(context);\n    eventModel.addItemContext(segments, context);\n  }\n  function removeItemContext(context) {\n    // TODO\n  }\n  function addBinding(binding) {\n    patchTextBinding(binding);\n    var expressions = binding.template.expressions;\n    if (expressions) {\n      for (var i = 0, len = expressions.length; i < len; i++) {\n        addDependencies(eventModel, expressions[i], binding);\n      }\n    } else {\n      var expression = binding.template.expression;\n      addDependencies(eventModel, expression, binding);\n    }\n  }\n  function removeBinding(binding) {\n    var bindingWrappers = binding.meta;\n    if (!bindingWrappers) return;\n    for (var i = bindingWrappers.length; i--;) {\n      eventModel.removeBinding(bindingWrappers[i]);\n    }\n  }\n  function removeNode(node) {\n    var component = node.$component;\n    if (component && !component.singleton) {\n      component.destroy();\n    }\n    var destroyListeners = node.$destroyListeners;\n    if (destroyListeners) {\n      for (var i = 0; i < destroyListeners.length; i++) {\n        destroyListeners[i]();\n      }\n    }\n  }\n};\n\nfunction addDependencies(eventModel, expression, binding) {\n  var bindingWrapper = new BindingWrapper(eventModel, expression, binding);\n  bindingWrapper.updateDependencies();\n}\n\n// The code here uses object-based set pattern where objects are keyed using\n// sequentially generated IDs.\nvar nextId = 1;\nfunction BindingWrapper(eventModel, expression, binding) {\n  this.eventModel = eventModel;\n  this.expression = expression;\n  this.binding = binding;\n  this.id = nextId++;\n  this.eventModels = null;\n  this.dependencies = null;\n  if (binding.meta) {\n    binding.meta.push(this);\n  } else {\n    binding.meta = [this];\n  }\n}\nBindingWrapper.prototype.updateDependencies = function() {\n  var dependencies = this.expression.dependencies(this.binding.context);\n  if (this.dependencies) {\n    // Do nothing if dependencies haven't changed\n    if (equalDependencies(this.dependencies, dependencies)) return;\n    // Otherwise, remove current dependencies\n    this.eventModel.removeBinding(this);\n  }\n  // Add new dependencies\n  if (!dependencies) return;\n  this.dependencies = dependencies;\n  for (var i = 0, len = dependencies.length; i < len; i++) {\n    var dependency = dependencies[i];\n    if (dependency) this.eventModel.addBinding(dependency, this);\n  }\n};\nBindingWrapper.prototype.update = function(previous, pass) {\n  this.binding.update(previous, pass);\n  this.updateDependencies();\n};\nBindingWrapper.prototype.insert = function(index, howMany) {\n  this.binding.insert(index, howMany);\n};\nBindingWrapper.prototype.remove = function(index, howMany) {\n  this.binding.remove(index, howMany);\n};\nBindingWrapper.prototype.move = function(from, to, howMany) {\n  this.binding.move(from, to, howMany);\n};\n\nfunction equalDependencies(a, b) {\n  var lenA = a ? a.length : -1;\n  var lenB = b ? b.length : -1;\n  if (lenA !== lenB) return false;\n  for (var i = 0; i < lenA; i++) {\n    var itemA = a[i];\n    var itemB = b[i];\n    var lenItemA = itemA ? itemA.length : -1;\n    var lenItemB = itemB ? itemB.length : -1;\n    if (lenItemA !== lenItemB) return false;\n    for (var j = 0; j < lenItemB; j++) {\n      if (itemA[j] !== itemB[j]) return false;\n    }\n  }\n  return true;\n}\n\nfunction patchTextBinding(binding) {\n  if (\n    binding instanceof templates.AttributeBinding &&\n    binding.name === 'value' &&\n    (binding.element.tagName === 'INPUT' || binding.element.tagName === 'TEXTAREA') &&\n    documentListeners.inputSupportsSelection(binding.element) &&\n    binding.template.expression.resolve(binding.context)\n  ) {\n    binding.update = textInputUpdate;\n  }\n}\n\nfunction textInputUpdate(previous, pass) {\n  textUpdate(this, this.element, previous, pass);\n}\nfunction textUpdate(binding, element, previous, pass) {\n  if (pass) {\n    if (pass.$event && pass.$event.target === element) {\n      return;\n    } else if (pass.$stringInsert) {\n      return textDiff.onStringInsert(\n        element,\n        previous,\n        pass.$stringInsert.index,\n        pass.$stringInsert.text\n      );\n    } else if (pass.$stringRemove) {\n      return textDiff.onStringRemove(\n        element,\n        previous,\n        pass.$stringRemove.index,\n        pass.$stringRemove.howMany\n      );\n    }\n  }\n  binding.template.update(binding.context, binding);\n}\n\nutil.serverRequire(module, './Page.server');\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/eventmodel.js":"var expressions = require('derby-templates').expressions;\n\n// The many trees of bindings:\n//\n// - Model tree, containing your actual data. Eg:\n//    {users:{fred:{age:40}, wilma:{age:37}}}\n//\n// - Event model tree, whose structure mirrors the model tree. The event model\n//   tree lets us annotate the model tree with listeners which fire when events\n//   change. I think there are three types of listeners:\n//\n//   1. Reference binding binds to whatever is referred to by the path. Eg,\n//   {{each items as item}} binds item by reference as it goes through the\n//   list.\n//   2. Fixed path bindings explicitly bind to whatever is at that path\n//   regardless of how the model changes underneath the event model\n//   3. Listen on a subtree and fire when anything in the subtree changes. This\n//   is used for custom functions.\n//\n// {{foo.id}} would listen on the fixed path ['foo', 'id'].\n//\n//\n// - Context tree represents the changing (embedded) contexts of the templating\n//   engine. This maps to the tree of templates and allows templates to reference\n//   anything in any of their enclosing template scopes.\n//\n\nmodule.exports = EventModel;\n\n// The code here uses object-based set pattern where objects are keyed using\n// sequentially generated IDs.\nvar nextId = 1;\n\n// A binding object is something with update(), insert()/move()/remove() defined.\n\n\n// Given x[y] with model.get(y) == 5:\n//  item = 5\n//  segments = ['y']\n//  outside = the EventModel for x.\n//\n// Note that item could be a Context or another ModelRef - eg:\n//\n// {{ each foo as bar }} ... {{ x[bar] }}  -or-  {{ x[y[z]] }}\nfunction ModelRef(model, item, segments, outside) {\n  this.id = nextId++;\n\n  // We need a reference to the model & our segment list so we can update our\n  // value.\n  this.model = model;\n  this.segments = segments;\n\n  // Our current value.\n  this.item = item;\n\n  // outside is a reference to the EventModel of the thing on the lhs of the\n  // brackets. For example, in x[y].z, outside is the EventModel of x.\n  this.outside = outside;\n\n  // result is the EventModel of the evaluated version of the brackets. In\n  // x[y].z, its the EventModel of x[y].\n  this.result = outside.child(item).refChild(this);\n}\n\nModelRef.prototype.update = function() {\n  var segments = expressions.pathSegments(this.segments);\n  var newItem = expressions.lookup(segments, this.model.data);\n  if (this.item === newItem) return;\n\n  // First remove myself.\n  delete this.outside.child(this.item).refChildren[this.id];\n\n  this.item = newItem;\n\n  var container = this.outside.child(this.item);\n  // I want to just call refChild but that would create a new EM. Instead I\n  // want to just implant my current EM there.\n  if (!container.refChildren) container.refChildren = new RefChildrenMap();\n  container.refChildren[this.id] = this.result;\n\n  // Finally, update all the bindings in the tree.\n  this.result.update();\n};\n\n\nfunction RefOutMap() {}\nfunction RefChildrenMap() {}\nfunction BindingsMap() {}\nfunction ItemContextsMap() {}\nfunction EventModelsMap() {}\n\nfunction EventModel() {\n  this.id = nextId++;\n\n  // Most of these won't ever be filled in, so I'm just leaving them null.\n  //\n  // These contain our EventModel children.\n  this.object = null;\n  this.array = null;\n\n  // This contains any EventModel children which have floating references.\n  this.arrayByReference = null;\n\n  // If the data stored here is ever used to lookup other values, this is an\n  // object mapping remote child ID -> ref.\n  //\n  // Eg given x[y], y.refOut[x.id] = <Binding>\n  this.refOut = null;\n\n  // This is a map from ref id -> event model for events bound to this\n  // EventModel but via a ref. We could just merge them into the main tree, but\n  // this way they're easy to move.\n  //\n  // Eg, given x[y] (y=1), x.1.refChildren[ref id] is an EventModel.\n  this.refChildren = null;\n\n  this.bindings = null;\n\n  // Item contexts are contexts which need their item number changed as this\n  // EventModel object moves around its surrounding list.\n  this.itemContexts = null;\n}\n\nEventModel.prototype.refChild = function(ref) {\n  if (!this.refChildren) this.refChildren = new RefChildrenMap();\n  var id = ref.id;\n\n  if (!this.refChildren[id]) {\n    this.refChildren[id] = new EventModel();\n  }\n  return this.refChildren[id];\n};\n\nEventModel.prototype.arrayLookup = function(model, segmentsBefore, segmentsInside) {\n  var segments = expressions.pathSegments(segmentsInside);\n  var item = expressions.lookup(segments, model.data);\n\n  var source = this.at(segmentsInside);\n\n  // What the array currently resolves to. Given x[y] with y=1, container is\n  // the EM for x\n  var container = this.at(segmentsBefore);\n\n  if (!source.refOut) source.refOut = new RefOutMap();\n\n  var ref = source.refOut[container.id];\n  if (ref == null) {\n    ref = new ModelRef(model, item, segmentsInside, container);\n    source.refOut[container.id] = ref;\n  }\n\n  return ref;\n};\n\n// Returns the EventModel node of the named child.\nEventModel.prototype.child = function(segment) {\n  var container;\n  if (typeof segment === 'string') {\n    // Object\n    if (!this.object) this.object = {};\n    container = this.object;\n\n  } else if (typeof segment === 'number') {\n    // Array by value\n    if (!this.array) this.array = [];\n    container = this.array;\n\n  } else if (segment instanceof ModelRef) {\n    // Array reference. We'll need to lookup the child with the right\n    // value, then look inside its ref children for the right EventModel\n    // (so we can update it later). This is pretty janky, but should be\n    // *correct* even in the face of recursive array accessors.\n    //\n    // This will calculate it based on the current segment values, but refs\n    // cache the EM anyway.\n    //return this.child(segment.item).refChild(segment);\n    return segment.result;\n\n  } else {\n    // Array by reference\n    if (!this.arrayByReference) this.arrayByReference = [];\n    container = this.arrayByReference;\n    segment = segment.item;\n  }\n\n  return container[segment] || (container[segment] = new EventModel());\n};\n\n// Returns the EventModel node at the given segments list. Note that although\n// EventModel nodes are unique, its possible for multiple EventModel nodes to\n// refer to the same section of the model because of references.\n//\n// If you want to update the bindings that refer to a specific path, use\n// each().\n//\n// EventModel objects are created as needed.\nEventModel.prototype.at = function(segments) {\n  // For unbound dependancies.\n  if (segments == null) return this;\n\n  var eventModel = this;\n\n  for (var i = 0; i < segments.length; i++) {\n    eventModel = eventModel.child(segments[i]);\n  }\n\n  return eventModel;\n};\n\nEventModel.prototype.isEmpty = function() {\n  if (hasKeys(this.dependancies)) return false;\n  if (hasKeys(this.itemContexts)) return false;\n\n  if (this.object) {\n    if (hasKeys(this.object)) return false;\n    this.object = null;\n  }\n\n  if (this.arrayByReference) {\n    for (var i = 0; i < this.arrayByReference.length; i++) {\n      if (this.arrayByReference[i] != null) return false;\n    }\n    this.arrayByReference = null;\n  }\n\n  if (this.array) {\n    for (var i = 0; i < this.array.length; i++) {\n      if (this.array[i] != null) return false;\n    }\n    this.array = null;\n  }\n\n  return true;\n};\n\nfunction hasKeys(object) {\n  for (var key in object) {\n    return true;\n  }\n  return false;\n}\n\n\n// **** Updating the EventModel\n\nEventModel.prototype._addItemContext = function(context) {\n  if (!context._id) context._id = nextId++;\n  if (!this.itemContexts) this.itemContexts = new ItemContextsMap();\n  this.itemContexts[context._id] = context;\n};\n\nEventModel.prototype._removeItemContext = function(context) {\n  if (this.itemContexts) {\n    delete this.itemContexts[context._id];\n  }\n};\n\nEventModel.prototype._addBinding = function(binding) {\n  var bindings = this.bindings || (this.bindings = new BindingsMap());\n  binding.eventModels || (binding.eventModels = new EventModelsMap());\n  bindings[binding.id] = binding;\n  binding.eventModels[this.id] = this;\n};\n\n// This is the main hook to add bindings to the event model tree. It should\n// only be called on the root EventModel object.\nEventModel.prototype.addBinding = function(segments, binding) {\n  this.at(segments)._addBinding(binding);\n};\n\n// This is used for objects (contexts in derby's case) that have a .item\n// property which refers to an array index.\nEventModel.prototype.addItemContext = function(segments, context) {\n  this.at(segments)._addItemContext(context);\n};\n\nEventModel.prototype.removeBinding = function(binding) {\n  if (!binding.eventModels) return;\n  for (var id in binding.eventModels) {\n    var eventModel = binding.eventModels[id];\n    if (eventModel.bindings) delete eventModel.bindings[binding.id];\n  }\n  binding.eventModels = null;\n};\n\nEventModel.prototype._each = function(segments, pos, fn) {\n  // Our refChildren are effectively merged into this object.\n  if (this.refChildren) {\n    for (var id in this.refChildren) {\n      var refChild = this.refChildren[id];\n      if (refChild) refChild._each(segments, pos, fn);\n    }\n  }\n\n  if (segments.length === pos) {\n    fn(this);\n    return;\n  }\n\n  var segment = segments[pos];\n  var child;\n  if (typeof segment === 'string') {\n    // Object. Just recurse into our objects set. Its possible to rewrite this\n    // function to simply loop in the case of object lookups, but I don't think\n    // it'll buy us much.\n    child = this.object && this.object[segment];\n    if (child) child._each(segments, pos + 1, fn);\n\n  } else {\n    // Number. Recurse both into the fixed list and the reference list.\n    child = this.array && this.array[segment];\n    if (child) child._each(segments, pos + 1, fn);\n\n    child = this.arrayByReference && this.arrayByReference[segment];\n    if (child) child._each(segments, pos + 1, fn);\n  }\n};\n\n// Called when the scalar value at the path changes. This only calls update()\n// on this node. See update() below if you want to update entire\n// subtrees.\nEventModel.prototype.localUpdate = function(previous, pass) {\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.update(previous, pass);\n    }\n  }\n\n  // If our value changed, we also need to update anything that depends on it\n  // via refOut.\n  if (this.refOut) {\n    for (var id in this.refOut) {\n      var ref = this.refOut[id];\n      if (ref) ref.update();\n    }\n  }\n};\n\n// This is used when an object subtree is replaced / removed.\nEventModel.prototype.update = function(previous, pass) {\n  this.localUpdate(previous, pass);\n\n  if (this.object) {\n    for (var key in this.object) {\n      var binding = this.object[key];\n      if (binding) binding.update();\n    }\n  }\n\n  if (this.array) {\n    for (var i = 0; i < this.array.length; i++) {\n      var binding = this.array[i];\n      if (binding) binding.update();\n    }\n  }\n\n  if (this.arrayByReference) {\n    for (var i = 0; i < this.arrayByReference.length; i++) {\n      var binding = this.arrayByReference[i];\n      if (binding) binding.update();\n    }\n  }\n};\n\n// Updates the indexes in itemContexts of our children in the range of\n// [from, to). from and to both optional.\nEventModel.prototype._updateChildItemContexts = function(from, to) {\n  if (!this.arrayByReference) return;\n\n  if (from == null) from = 0;\n  if (to == null) to = this.arrayByReference.length;\n\n  for (var i = from; i < to; i++) {\n    var contexts = this.arrayByReference[i] &&\n      this.arrayByReference[i].itemContexts;\n    if (contexts) {\n      for (var key in contexts) {\n        contexts[key].item = i;\n      }\n    }\n  }\n};\n\n// Updates our array-by-value values. They have to recursively update every\n// binding in their children. Sad.\nEventModel.prototype._updateArray = function(from, to) {\n  if (!this.array) return;\n\n  if (from == null) from = 0;\n  if (to == null) to = this.array.length;\n\n  for (var i = from; i < to; i++) {\n    var binding = this.array[i];\n    if (binding) binding.update();\n  }\n};\n\nEventModel.prototype._updateObject = function() {\n  if (this.object) {\n    for (var key in this.object) {\n      var binding = this.object[key];\n      if (binding) binding.update();\n    }\n  }\n};\n\nEventModel.prototype._set = function(previous, pass) {\n  // This just updates anything thats bound to the whole subtree. An alternate\n  // implementation could be passed in the new value at this node (which we\n  // cache), then compare with the old version and only update parts of the\n  // subtree which are relevant. I don't know if thats an important\n  // optimization - it really depends on your use case.\n  this.update(previous, pass);\n};\n\n// Insert into this EventModel node.\nEventModel.prototype._insert = function(index, howMany) {\n  // Update fixed paths\n  this._updateArray(index);\n\n  // Update relative paths\n  if (this.arrayByReference && this.arrayByReference.length > index) {\n    // Shift the actual items in the array references array.\n\n    // This probably isn't the best way to implement insert. Other options are\n    // using concat() on slices or though constructing a temporary array and\n    // using splice.call. Hopefully if this method is slow it'll come up during\n    // profiling.\n    for (var i = 0; i < howMany; i++) {\n      this.arrayByReference.splice(index, 0, null);\n    }\n\n    // Update the path in the contexts\n    this._updateChildItemContexts(index + howMany);\n  }\n\n  // Finally call our bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.insert(index, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n// Remove howMany child elements from this EventModel at index.\nEventModel.prototype._remove = function(index, howMany) {\n  // Update fixed paths. Both the removed items and items after it may have changed.\n  this._updateArray(index);\n\n  if (this.arrayByReference) {\n    // Update relative paths. First throw away all the children which have been removed.\n    this.arrayByReference.splice(index, howMany);\n\n    this._updateChildItemContexts(index);\n  }\n\n  // Call bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.remove(index, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n// Move howMany items from `from` to `to`.\nEventModel.prototype._move = function(from, to, howMany) {\n  // first points to the first element that was moved. end points to the list\n  // element past the end of the changed region.\n  var first, end;\n  if (from < to) {\n    first = from;\n    end = to + howMany;\n  } else {\n    first = to;\n    end = from + howMany;\n  }\n\n  // Update fixed paths.\n  this._updateArray(first, end);\n\n  // Update relative paths\n  var arr = this.arrayByReference;\n  if (arr && arr.length > first) {\n    // Remove from the old location\n    var values = arr.splice(from, howMany);\n\n    // Insert at the new location\n    arr.splice.apply(arr, [to, 0].concat(values));\n\n    // Update the path in the contexts\n    this._updateChildItemContexts(first, end);\n  }\n\n  // Finally call our bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.move(from, to, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n\n// Helpers.\n\nEventModel.prototype.mutate = function(segments, fn) {\n  // This finds & returns a list of all event models which exist and could match\n  // the specified path. The path cannot contain contexts like derby expression\n  // segment lists (just because I don't think thats a useful feature and its not\n  // implemented)\n  this._each(segments, 0, fn);\n\n  // Also emit all mutations as sets on star paths, which are how dependencies\n  // for view helper functions are represented. They should react to a path\n  // or any child path being modified\n  for (var i = 0, len = segments.length; i++ < len;) {\n    var wildcardSegments = segments.slice(0, i);\n    wildcardSegments.push('*');\n    this._each(wildcardSegments, 0, childSetWildcard);\n  }\n};\n\nfunction childSetWildcard(child) {\n  child._set();\n}\n\nEventModel.prototype.set = function(segments, previous, pass) {\n  this.mutate(segments, function childSet(child) {\n    child._set(previous, pass);\n  });\n};\n\nEventModel.prototype.insert = function(segments, index, howMany) {\n  this.mutate(segments, function childInsert(child) {\n    child._insert(index, howMany);\n  });\n};\n\nEventModel.prototype.remove = function(segments, index, howMany) {\n  this.mutate(segments, function childRemove(child) {\n    child._remove(index, howMany);\n  });\n};\n\nEventModel.prototype.move = function(segments, from, to, howMany) {\n  this.mutate(segments, function childMove(child) {\n    child._move(from, to, howMany);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/Controller.js":"var EventEmitter = require('events').EventEmitter;\nvar util = require('racer/lib/util');\nvar Dom = require('./Dom');\n\nmodule.exports = Controller;\n\nfunction Controller(app, page, model) {\n  EventEmitter.call(this);\n  this.dom = new Dom(this);\n  this.app = app;\n  this.page = page;\n  this.model = model;\n  model.data.$controller = this;\n}\n\nutil.mergeInto(Controller.prototype, EventEmitter.prototype);\n\nController.prototype.emitCancellable = function() {\n  var cancelled = false;\n  function cancel() {\n    cancelled = true;\n  }\n\n  var args = Array.prototype.slice.call(arguments);\n  args.push(cancel);\n  this.emit.apply(this, args);\n\n  return cancelled;\n};\n\nController.prototype.emitDelayable = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var callback = args.pop();\n\n  var delayed = false;\n  function delay() {\n    delayed = true;\n    return callback;\n  }\n\n  args.push(delay);\n  this.emit.apply(this, args);\n  if (!delayed) callback();\n\n  return delayed;\n};\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/Dom.js":"module.exports = Dom;\n\nfunction Dom(controller) {\n  this.controller = controller;\n  this._listeners = null;\n}\n\nDom.prototype._initListeners = function() {\n  var dom = this;\n  this.controller.on('destroy', function domOnDestroy() {\n    var listeners = dom._listeners;\n    if (!listeners) return;\n    for (var i = listeners.length; i--;) {\n      listeners[i].remove();\n    }\n    dom._listeners = null;\n  });\n  return this._listeners = [];\n};\n\nDom.prototype._listenerIndex = function(domListener) {\n  var listeners = this._listeners;\n  if (!listeners) return -1;\n  for (var i = listeners.length; i--;) {\n    if (listeners[i].equals(domListener)) return i;\n  }\n  return -1;\n};\n\nDom.prototype.addListener = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  var domListener =\n    (type === 'destroy') ? new DestroyListener(target, listener) :\n    new DomListener(type, target, listener, useCapture);\n  if (-1 === this._listenerIndex(domListener)) {\n    var listeners = this._listeners || this._initListeners();\n    listeners.push(domListener);\n  }\n  domListener.add();\n};\nDom.prototype.on = Dom.prototype.addListener;\n\nDom.prototype.once = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  this.addListener(type, target, wrappedListener, useCapture);\n  var dom = this;\n  function wrappedListener() {\n    dom.removeListener(type, target, wrappedListener, useCapture);\n    return listener.apply(this, arguments);\n  }\n};\n\nDom.prototype.removeListener = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  var domListener = new DomListener(type, target, listener, useCapture);\n  domListener.remove();\n  var i = this._listenerIndex(domListener);\n  if (i > -1) this._listeners.splice(i, 1);\n};\n\nfunction DomListener(type, target, listener, useCapture) {\n  this.type = type;\n  this.target = target;\n  this.listener = listener;\n  this.useCapture = !!useCapture;\n}\nDomListener.prototype.equals = function(domListener) {\n  return this.listener === domListener.listener &&\n    this.target === domListener.target &&\n    this.type === domListener.type &&\n    this.useCapture === domListener.useCapture;\n};\nDomListener.prototype.add = function() {\n  this.target.addEventListener(this.type, this.listener, this.useCapture);\n};\nDomListener.prototype.remove = function() {\n  this.target.removeEventListener(this.type, this.listener, this.useCapture);\n};\n\nfunction DestroyListener(target, listener) {\n  DomListener.call(this, 'destroy', target, listener);\n}\nDestroyListener.prototype = new DomListener();\nDestroyListener.prototype.add = function() {\n  var listeners = this.target.$destroyListeners || (this.target.$destroyListeners = []);\n  if (listeners.indexOf(this.listener) === -1) {\n    listeners.push(this.listener);\n  }\n};\nDestroyListener.prototype.remove = function() {\n  var listeners = this.target.$destroyListeners;\n  if (!listeners) return;\n  var index = listeners.indexOf(this.listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/Page.server.js":"var Page = require('./Page');\nvar util = require('racer/lib/util');\nvar contexts = require('derby-templates').contexts;\n\nPage.prototype.render = function(status, ns) {\n  if (typeof status !== 'number') {\n    ns = status;\n    status = null;\n  }\n  this.app.emit('render', this);\n\n  if (status) this.res.statusCode = status;\n  // Prevent the browser from storing the HTML response in its back cache, since\n  // that will cause it to render with the data from the initial load first\n  this.res.setHeader('Cache-Control', 'no-store');\n  // Set HTML utf-8 content type unless already set\n  if (!this.res.getHeader('Content-Type')) {\n    this.res.setHeader('Content-Type', 'text/html; charset=utf-8');\n  }\n\n  this._setRenderParams(ns);\n  var pageHtml = this.get('Page', ns);\n  this.res.write(pageHtml);\n\n  var bundleScriptTag = '<script async data-derby-app src=\"' + this.app.scriptUrl + '\"';\n  if (this.app.scriptCrossOrigin) {\n    // Scripts loaded from a different origin (such as a CDN) won't report\n    // much information to the host page's window.onerror. Adding the\n    // \"crossorigin\" attribute to the script tag allows reporting of detailed\n    // error info to the host page.\n    // HOWEVER - if the \"crossorigin\" attribute is present for a script tag\n    // with a cross-origin \"src\", then the script's HTTP response MUST have\n    // an appropriate \"Access-Control-Allow-Origin\" header set. Otherwise,\n    // the browser will refuse to load the script.\n    bundleScriptTag += ' crossorigin';\n  }\n  bundleScriptTag += '></script>';\n  this.res.write(bundleScriptTag);\n\n  this.res.write('<script type=\"application/json\">');\n  var tailHtml = this.get('Tail', ns);\n\n  this.model.destroy('$components');\n\n  var page = this;\n  this.model.bundle(function(err, bundle) {\n    if (page.model.hasErrored) return;\n    if (err) return page.emit('error', err);\n    var json = stringifyBundle(bundle);\n    page.res.write(json);\n    page.res.end('</script>' + tailHtml);\n    page.app.emit('routeDone', page, 'render');\n  });\n};\n\nPage.prototype.renderStatic = function(status, ns) {\n  if (typeof status !== 'number') {\n    ns = status;\n    status = null;\n  }\n  this.app.emit('renderStatic', this);\n\n  if (status) this.res.statusCode = status;\n  this.params = pageParams(this.req);\n  this._setRenderParams(ns);\n  var pageHtml = this.get('Page', ns);\n  var tailHtml = this.get('Tail', ns);\n  this.res.send(pageHtml + tailHtml);\n  this.app.emit('routeDone', this, 'renderStatic');\n};\n\n// Don't register any listeners on the server\nPage.prototype._addListeners = function() {};\n\nfunction stringifyBundle(bundle) {\n  var json = JSON.stringify(bundle);\n  return json.replace(/<[\\/!]/g, function(match) {\n    // Replace the end tag sequence with an equivalent JSON string to make\n    // sure the script is not prematurely closed\n    if (match === '</') return '<\\\\/';\n    // Replace the start of an HTML comment tag sequence with an equivalent\n    // JSON string\n    if (match === '<!') return '<\\\\u0021';\n    throw new Error('Unexpected match when escaping JSON');\n  });\n}\n\n// TODO: Cleanup; copied from tracks\nfunction pageParams(req) {\n  var params = {\n    url: req.url\n  , body: req.body\n  , query: req.query\n  };\n  for (var key in req.params) {\n    params[key] = req.params[key];\n  }\n  return params;\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/_views.js":"// This file is intentionally empty.\n// It's used in browserifying as the placeholder for serialized views.\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/App.server.js":"/*\n * App.server.js\n *\n * Application level functionality that is\n * only applicable to the server.\n *\n */\n\nvar crypto = require('crypto');\nvar fs = require('fs');\nvar path = require('path');\nvar chokidar = require('chokidar');\nvar through = require('through');\nvar derbyTemplates = require('derby-templates');\nvar racer = require('racer');\nvar util = racer.util;\nvar App = require('./App');\nvar files = require('./files');\n\nvar STYLE_EXTENSIONS = ['.css'];\nvar VIEW_EXTENSIONS = ['.html'];\nvar COMPILERS = {\n  '.css': files.cssCompiler\n, '.html': files.htmlCompiler\n};\n\nApp.prototype._init = function(options) {\n  this.scriptFilename = null;\n  this.scriptMapFilename = null;\n  this.scriptBaseUrl = (options && options.scriptBaseUrl) || '';\n  this.scriptMapBaseUrl = (options && options.scriptMapBaseUrl) || '';\n  this.scriptCrossOrigin = (options && options.scriptCrossOrigin) || false;\n  this.scriptUrl = null;\n  this.scriptMapUrl = null;\n  this.agents = null;\n  this.styleExtensions = STYLE_EXTENSIONS.slice();\n  this.viewExtensions = VIEW_EXTENSIONS.slice();\n  this.compilers = util.copyObject(COMPILERS);\n\n  this.serializedDir = path.dirname(this.filename || '') + '/derby-serialized';\n  this.serializedBase = this.serializedDir + '/' + this.name;\n  if (fs.existsSync(this.serializedBase + '.json')) {\n    this.deserialize();\n    this.loadViews = function() {};\n    this.loadStyles = function() {};\n    return;\n  }\n  this.views.register('Page',\n    '<!DOCTYPE html>' +\n    '<meta charset=\"utf-8\">' +\n    '<view is=\"{{$render.prefix}}TitleElement\"></view>' +\n    '<view is=\"{{$render.prefix}}Styles\"></view>' +\n    '<view is=\"{{$render.prefix}}Head\"></view>' +\n    '<view is=\"{{$render.prefix}}BodyElement\"></view>',\n    {serverOnly: true}\n  );\n  this.views.register('TitleElement',\n    '<title><view is=\"{{$render.prefix}}Title\"></view></title>'\n  );\n  this.views.register('BodyElement',\n    '<body class=\"{{$bodyClass($render.ns)}}\">' +\n      '<view is=\"{{$render.prefix}}Body\"></view>'\n  );\n  this.views.register('Title', 'Derby App');\n  this.views.register('Styles', '', {serverOnly: true});\n  this.views.register('Head', '', {serverOnly: true});\n  this.views.register('Body', '');\n  this.views.register('Tail', '');\n};\n\nApp.prototype.createPage = function(req, res, next) {\n  var model = req.model || new racer.Model();\n  this.emit('model', model);\n  var page = new this.Page(this, model, req, res);\n  if (next) {\n    model.on('error', function(err){\n      model.hasErrored = true;\n      next(err);\n    });\n    page.on('error', next);\n  }\n  return page;\n};\n\nApp.prototype.bundle = function(backend, options, cb) {\n  var app = this;\n  if (typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n  options || (options = {});\n  if (options.minify == null) options.minify = util.isProduction;\n  // Turn all of the app's currently registered views into a javascript\n  // function that can recreate them in the client\n  var viewsSource = this._viewsSource(options);\n  var bundleFiles = [];\n  backend.once('bundle', function(bundle) {\n    bundle.require(path.dirname(__dirname), {expose: 'derby'});\n    // Hack to inject the views script into the Browserify bundle by replacing\n    // the empty _views.js file with the generated source\n    var viewsFilename = require.resolve('./_views');\n    bundle.transform(function(filename) {\n      if (filename !== viewsFilename) return through();\n      return through(\n        function write() {}\n      , function end() {\n          this.queue(viewsSource);\n          this.queue(null);\n        }\n      );\n    }, {global: true});\n    bundle.on('file', function(filename) {\n      bundleFiles.push(filename);\n    });\n    app.emit('bundle', bundle);\n  });\n  backend.bundle(app.filename, options, function(err, source, map) {\n    if (err) return cb(err);\n    app.scriptHash = crypto.createHash('md5').update(source).digest('hex');\n    source = source.replace('{{DERBY_SCRIPT_HASH}}', app.scriptHash);\n    source = source.replace(/['\"]{{DERBY_BUNDLED_AT}}['\"]/, Date.now());\n    if (!util.isProduction) {\n      app._autoRefresh(backend);\n      app._watchBundle(bundleFiles);\n    }\n    cb(null, source, map);\n  });\n};\n\nApp.prototype.writeScripts = function(backend, dir, options, cb) {\n  var app = this;\n  this.bundle(backend, options, function(err, source, map) {\n    if (err) return cb(err);\n    dir = path.join(dir, 'derby');\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir);\n    var filename = app.name + '-' + app.scriptHash;\n    var base = path.join(dir, filename);\n    app.scriptUrl = app.scriptBaseUrl + '/derby/' + filename + '.js';\n\n    // Write current map and bundle files\n    if (!(options && options.disableScriptMap)) {\n      app.scriptMapUrl = app.scriptMapBaseUrl +  '/derby/' + filename + '.map.json';\n      source += '\\n//# sourceMappingURL=' + app.scriptMapUrl;\n      app.scriptMapFilename = base + '.map.json';\n      fs.writeFileSync(app.scriptMapFilename, map, 'utf8');\n    }\n    app.scriptFilename = base + '.js';\n    fs.writeFileSync(app.scriptFilename, source, 'utf8');\n\n    // Delete app bundles with same name in development so files don't\n    // accumulate. Don't do this automatically in production, since there could\n    // be race conditions with multiple processes intentionally running\n    // different versions of the app in parallel out of the same directory,\n    // such as during a rolling restart.\n    if (!util.isProduction) {\n      var appPrefix = app.name + '-';\n      var currentBundlePrefix = appPrefix + app.scriptHash;\n      var filenames = fs.readdirSync(dir);\n      for (var i = 0; i < filenames.length; i++) {\n        var filename = filenames[i];\n        if (filename.indexOf(appPrefix) !== 0) {\n          // Not a bundle for this app, skip.\n          continue;\n        }\n        if (filename.indexOf(currentBundlePrefix) === 0) {\n          // Current (newly written) bundle for this app, skip.\n          continue;\n        }\n        // Older bundle for this app, clean it up.\n        var oldFilename = path.join(dir, filename);\n        fs.unlinkSync(oldFilename);\n      }\n    }\n    cb && cb();\n  });\n};\n\nApp.prototype._viewsSource = function(options) {\n  return '/*DERBY_SERIALIZED_VIEWS*/' +\n    'module.exports = ' + this.views.serialize(options) + ';' +\n    '/*DERBY_SERIALIZED_VIEWS_END*/';\n};\n\nApp.prototype.serialize = function() {\n  if (!fs.existsSync(this.serializedDir)) {\n    fs.mkdirSync(this.serializedDir);\n  }\n  // Don't minify the views (which doesn't include template source), since this\n  // is for use on the server\n  var viewsSource = this._viewsSource({server: true, minify: true});\n  fs.writeFileSync(this.serializedBase + '.views.js', viewsSource, 'utf8');\n  var scriptUrl = (this.scriptUrl.indexOf(this.scriptBaseUrl) === 0) ?\n    this.scriptUrl.slice(this.scriptBaseUrl.length) :\n    this.scriptUrl;\n  var scriptMapUrl = (this.scriptMapUrl.indexOf(this.scriptMapBaseUrl) === 0) ?\n    this.scriptMapUrl.slice(this.scriptMapBaseUrl.length) :\n    this.scriptMapUrl;\n  var serialized = JSON.stringify({\n    scriptBaseUrl: this.scriptBaseUrl\n  , scriptMapBaseUrl: this.scriptMapBaseUrl\n  , scriptUrl: scriptUrl\n  , scriptMapUrl: scriptMapUrl\n  });\n  fs.writeFileSync(this.serializedBase + '.json', serialized, 'utf8');\n};\n\nApp.prototype.deserialize = function() {\n  var serializedViews = require(this.serializedBase + '.views.js');\n  var serialized = require(this.serializedBase + '.json');\n  serializedViews(derbyTemplates, this.views);\n  this.scriptUrl = (this.scriptBaseUrl || serialized.scriptBaseUrl) + serialized.scriptUrl;\n  this.scriptMapUrl = (this.scriptMapBaseUrl || serialized.scriptMapBaseUrl) + serialized.scriptMapUrl;\n};\n\nApp.prototype.loadViews = function(filename, namespace) {\n  var data = files.loadViewsSync(this, filename, namespace);\n  for (var i = 0, len = data.views.length; i < len; i++) {\n    var item = data.views[i];\n    this.views.register(item.name, item.source, item.options);\n  }\n  if (!util.isProduction) this._watchViews(data.files, filename, namespace);\n  // Make chainable\n  return this;\n};\n\nApp.prototype.loadStyles = function(filename, options) {\n  this._loadStyles(filename, options);\n  var stylesView = this.views.find('Styles');\n  stylesView.source += '<view is=\"' + filename + '\"></view>';\n  // Make chainable\n  return this;\n};\n\nApp.prototype._loadStyles = function(filename, options) {\n  var styles = files.loadStylesSync(this, filename, options);\n\n  var filepath = '';\n  if (!util.isProduction) {\n    /**\n     * Mark the path to file as an attribute\n     * Used in development to add event watchers and autorefreshing of styles\n     * SEE: local file, method this._watchStyles\n     * SEE: file ./App.js, method App._autoRefresh()\n     */\n    filepath = ' data-filename=\"' + filename + '\"';\n  }\n  var source = '<style' + filepath + '>' + styles.css + '</style>';\n\n  this.views.register(filename, source, {\n    serverOnly: true\n  });\n\n  if (!util.isProduction) {\n    this._watchStyles(styles.files, filename, options);\n  }\n\n  return styles;\n};\n\nApp.prototype._watchViews = function(filenames, filename, namespace) {\n  var app = this;\n  var watcher = chokidar.watch(filenames);\n  watcher.on('change', function() {\n    watcher.close();\n    app.loadViews(filename, namespace);\n    app._updateScriptViews();\n    app._refreshClients();\n  });\n};\n\nApp.prototype._watchStyles = function(filenames, filename, options) {\n  var app = this;\n  var watcher = chokidar.watch(filenames);\n  watcher.on('change', function() {\n    watcher.close();\n    var styles = app._loadStyles(filename, options);\n    app._updateScriptViews();\n    app._refreshStyles(filename, styles);\n  });\n};\n\nApp.prototype._watchBundle = function(filenames) {\n  if (!process.send) return;\n  var app = this;\n  var watcher = chokidar.watch(filenames);\n  watcher.on('change', function() {\n    watcher.close();\n    process.send({type: 'reload'});\n  });\n};\n\nApp.prototype._updateScriptViews = function() {\n  if (!this.scriptFilename) return;\n  var script = fs.readFileSync(this.scriptFilename, 'utf8');\n  var i = script.indexOf('/*DERBY_SERIALIZED_VIEWS*/');\n  var before = script.slice(0, i);\n  var i = script.indexOf('/*DERBY_SERIALIZED_VIEWS_END*/');\n  var after = script.slice(i + 30);\n  var viewsSource = this._viewsSource();\n  fs.writeFileSync(this.scriptFilename, before + viewsSource + after, 'utf8');\n};\n\nApp.prototype._autoRefresh = function(backend) {\n  var agents = this.agents = {};\n  var app = this;\n\n  backend.use('receive', function(request, next) {\n    var data = request.data;\n    if (data.derby) {\n      return app._handleMessage(request.agent, data.derby, data);\n    }\n    next();\n  });\n};\n\nApp.prototype._handleMessage = function(agent, action, message) {\n  if (action === 'app') {\n    if (message.name !== this.name) {\n      return;\n    }\n    if (message.hash !== this.scriptHash) {\n      return agent.send({derby: 'reload'});\n    }\n    this._addAgent(agent);\n  }\n};\n\nApp.prototype._addAgent = function(agent) {\n  this.agents[agent.clientId] = agent;\n  var app = this;\n  agent.stream.once('end', function() {\n    delete app.agents[agent.clientId];\n  });\n};\n\nApp.prototype._refreshClients = function() {\n  if (!this.agents) return;\n  var views = this.views.serialize({minify: true});\n  var message = {\n    derby: 'refreshViews',\n    views: views\n  };\n  for (var id in this.agents) {\n    this.agents[id].send(message);\n  }\n};\n\nApp.prototype._refreshStyles = function(filename, styles) {\n  if (!this.agents) return;\n  var data = {filename: filename, css: styles.css};\n  var message = {\n    derby: 'refreshStyles',\n    filename: filename,\n    css: styles.css\n  };\n  for (var id in this.agents) {\n    this.agents[id].send(message);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/files.js":"/*\n * files.js\n * loads templates, configurations and other files from disk\n *\n */\n\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('racer/lib/util');\nvar htmlUtil = require('html-util');\nvar resolve = require('resolve');\n\nexports.loadViewsSync = loadViewsSync;\nexports.loadStylesSync = loadStylesSync;\nexports.cssCompiler = cssCompiler;\nexports.htmlCompiler = htmlCompiler;\n\nfunction loadViewsSync(app, sourceFilename, namespace) {\n  var views = [];\n  var files = [];\n  var resolved = resolve.sync(sourceFilename, {extensions: app.viewExtensions, packageFilter: deleteMain});\n  if (!resolved) {\n    throw new Error('View template file not found: ' + sourceFilename);\n  }\n\n  var file = fs.readFileSync(resolved, 'utf8');\n\n  var extension = path.extname(resolved);\n  var compiler = app.compilers[extension];\n  if (!compiler) {\n    throw new Error('Unable to find compiler for: ' + extension);\n  }\n\n  var htmlFile = compiler(file, resolved);\n\n  var parsed = parseViews(namespace, htmlFile, resolved, app.viewExtensions);\n  for (var i = 0, len = parsed.imports.length; i < len; i++) {\n    var item = parsed.imports[i];\n    var imported = loadViewsSync(app, item.filename, item.namespace);\n    views = views.concat(imported.views);\n    files = files.concat(imported.files);\n  }\n  return {\n    views: views.concat(parsed.views)\n  , files: files.concat(resolved)\n  };\n}\n\nfunction htmlCompiler(file, filename) {\n  return file;\n}\n\nfunction parseViews(namespace, file, filename, extensions) {\n  var imports = [];\n  var views = [];\n  var prefix = (namespace) ? namespace + ':' : '';\n\n  htmlUtil.parse(file + '\\n', {\n    // Force view tags to be treated as raw tags,\n    // meaning their contents are not parsed as HTML\n    rawTags: /^(?:[^\\s=\\/!>]+:|style|script)$/i\n  , matchEnd: matchEnd\n  , start: onStart\n  , text: onText\n  });\n\n  function matchEnd(tagName) {\n    if (tagName.slice(-1) === ':') {\n      return /<\\/?[^\\s=\\/!>]+:[\\s>]/i;\n    }\n    return new RegExp('</' + tagName, 'i');\n  }\n\n  // These variables pass state from attributes in the start tag to the\n  // following view template text\n  var name, attrs;\n\n  function onStart(tag, tagName, tagAttrs) {\n    var lastChar = tagName.charAt(tagName.length - 1);\n    if (lastChar !== ':') {\n      throw new Error('Expected tag ending in colon (:) instead of ' + tag);\n    }\n    name = tagName.slice(0, -1);\n    attrs = tagAttrs;\n    if (name === 'import') {\n      var dir = path.dirname(filename);\n      var resolved = resolve.sync(attrs.src, {basedir: dir, extensions: extensions, packageFilter: deleteMain});\n      var extension = path.extname(resolved);\n      var importNamespace = (attrs.ns == null) ?\n        path.basename(attrs.src, extension) : attrs.ns;\n      imports.push({\n        filename: resolved\n      , namespace: (!importNamespace) ? namespace : prefix + importNamespace\n      });\n    }\n  }\n\n  function onText(text, isRawText) {\n    if (!name || name === 'import') return;\n    views.push({\n      name: prefix + name\n    , source: text\n    , options: attrs\n    , filename: filename\n    });\n  }\n\n  return {\n    imports: imports\n  , views: views\n  };\n}\n\nfunction loadStylesSync(app, sourceFilename, options) {\n  options || (options = {compress: util.isProduction});\n  var resolved = resolve.sync(sourceFilename, {extensions: app.styleExtensions, packageFilter: deleteMain});\n  if (!resolved) {\n    throw new Error('Style file not found: ' + sourceFilename);\n  }\n  var extension = path.extname(resolved);\n  var compiler = app.compilers[extension];\n  if (!compiler) {\n    throw new Error('Unable to find compiler for: ' + extension);\n  }\n  var file = fs.readFileSync(resolved, 'utf8');\n  return compiler(file, resolved, options);\n}\n\nfunction cssCompiler(file, filename, options) {\n  return {css: file, files: [filename]};\n}\n\n// Resolve will use a main path from a package.json if found. Main is the\n// entry point for javascript in a module, so this will mistakenly cause us to\n// load the JS file instead of a view or style file in some cases. This package\n// filter deletes the main property so that the normal file name lookup happens\nfunction deleteMain(package) {\n  delete package.main;\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/components.js":"/*\n * components.js\n *\n * Components associate custom script functionality with a view. They can be\n * distributed as standalone modules containing templates, scripts, and styles.\n * They can also be used to modularize application functionality.\n *\n */\n\nvar path = require('path');\nvar util = require('racer/lib/util');\nvar derbyTemplates = require('derby-templates');\nvar templates = derbyTemplates.templates;\nvar expressions = derbyTemplates.expressions;\nvar App = require('./App');\nvar Controller = require('./Controller');\n\nexports.Component = Component;\nexports.ComponentFactory = ComponentFactory;\nexports.SingletonComponentFactory = SingletonComponentFactory;\nexports.createFactory = createFactory;\n\nfunction Component(parent, context, id, scope) {\n  this.parent = parent;\n  this.context = context;\n  this.id = id;\n  this._scope = scope;\n}\n\nutil.mergeInto(Component.prototype, Controller.prototype);\n\nComponent.prototype.destroy = function() {\n  this.emit('destroy');\n  this.model.removeContextListeners();\n  this.model.destroy();\n  delete this.page._components[this.id];\n  var components = this.page._eventModel.object.$components;\n  if (components) delete components.object[this.id];\n};\n\nComponent.prototype.get = function(viewName, unescaped) {\n  var view = this.getView(viewName);\n  return view.get(this.context, unescaped);\n};\n\nComponent.prototype.getFragment = function(viewName) {\n  var view = this.getView(viewName);\n  return view.getFragment(this.context);\n};\n\nComponent.prototype.getView = function(viewName) {\n  var contextView = this.context.getView();\n  return (viewName) ?\n    this.app.views.find(viewName, contextView.namespace) : contextView;\n};\n\nComponent.prototype.getAttribute = function(key) {\n  var attributeContext = this.context.forAttribute(key);\n  if (!attributeContext) return;\n  var value = attributeContext.attributes[key];\n  return value && expressions.renderValue(value, attributeContext);\n};\n\nComponent.prototype.setAttribute = function(key, value) {\n  this.context.parent.attributes[key] = value;\n};\n\nComponent.prototype.setNullAttribute = function(key, value) {\n  var attributes = this.context.parent.attributes;\n  if (attributes[key] == null) attributes[key] = value;\n};\n\nfunction initComponent(context, component, parent, model, id, scope) {\n  // Do generic controller initialization\n  var componentContext = context.componentChild(component);\n  Controller.call(component, parent.app, parent.page, model);\n  Component.call(component, parent, componentContext, id, scope);\n\n  // Do the user-specific initialization. The component constructor should be\n  // an empty function and the actual initialization code should be done in the\n  // component's init method. This means that we don't have to rely on users\n  // properly calling the Component constructor method and avoids having to\n  // play nice with how CoffeeScript extends class constructors\n  emitInitHooks(context, component);\n  component.emit('init', component);\n  if (component.init) component.init(model);\n\n  return componentContext;\n}\n\nfunction emitInitHooks(context, component) {\n  if (!context.initHooks) return;\n  // Run initHooks for `on` listeners immediately before init\n  for (var i = 0, len = context.initHooks.length; i < len; i++) {\n    context.initHooks[i].emit(context, component);\n  }\n}\n\nfunction setAttributes(context, model) {\n  if (!context.attributes) return;\n  // Set attribute values on component model\n  for (var key in context.attributes) {\n    var attribute = context.attributes[key];\n    var segments = (\n      attribute instanceof templates.ParentWrapper &&\n      attribute.expression &&\n      attribute.expression.pathSegments(context)\n    );\n    if (segments) {\n      model.root.ref(model._at + '.' + key, segments.join('.'), {updateIndices: true});\n    } else {\n      model.set(key, attribute);\n    }\n  }\n}\n\nfunction createFactory(constructor) {\n  return (constructor.prototype.singleton) ?\n    new SingletonComponentFactory(constructor) :\n    new ComponentFactory(constructor);\n}\n\nfunction ComponentFactory(constructor) {\n  this.constructor = constructor;\n}\nComponentFactory.prototype.init = function(context) {\n  var component = new this.constructor();\n\n  var parent = context.controller;\n  var id = context.id();\n  var scope = ['$components', id];\n  var model = parent.model.root.eventContext(component);\n  model._at = scope.join('.');\n  model.set('id', id);\n  setAttributes(context, model);\n  // Store a reference to the component's scope such that the expression\n  // getters are relative to the component\n  model.data = model.get();\n  parent.page._components[id] = component;\n\n  return initComponent(context, component, parent, model, id, scope);\n};\nComponentFactory.prototype.create = function(context) {\n  var component = context.controller;\n  component.emit('create', component);\n  // Call the component's create function after its view is rendered\n  if (component.create) {\n    component.create(component.model, component.dom);\n  }\n};\n\nfunction SingletonComponentFactory(constructor) {\n  this.constructor = constructor;\n  this.component = null;\n}\nSingletonComponentFactory.prototype.init = function(context) {\n  if (!this.component) this.component = new this.constructor();\n  return context.componentChild(this.component);\n};\n// Don't call the create method for singleton components\nSingletonComponentFactory.prototype.create = function() {};\n\nApp.prototype.component = function(viewName, constructor) {\n  if (typeof viewName === 'function') {\n    constructor = viewName;\n    viewName = null;\n  }\n\n  // Inherit from Component\n  extendComponent(constructor);\n\n  // Load template view from filename\n  if (constructor.prototype.view) {\n    var viewFilename = constructor.prototype.view;\n    viewName = constructor.prototype.name || path.basename(viewFilename, '.html');\n    this.loadViews(viewFilename, viewName);\n\n  } else if (!viewName) {\n    if (constructor.prototype.name) {\n      viewName = constructor.prototype.name;\n      var view = this.views.register(viewName);\n      view.template = templates.emptyTemplate;\n    } else {\n      throw new Error('No view name specified for component');\n    }\n  }\n\n  // Associate the appropriate view with the component type\n  var view = this.views.find(viewName);\n  if (!view) {\n    var message = this.views.findErrorMessage(viewName);\n    throw new Error(message);\n  }\n  view.componentFactory = createFactory(constructor);\n\n  // Make chainable\n  return this;\n};\n\nfunction extendComponent(constructor) {\n  // Don't do anything if the constructor already extends Component\n  if (constructor.prototype instanceof Component) return;\n  // Otherwise, replace its prototype with an instance of Component\n  var oldPrototype = constructor.prototype;\n  constructor.prototype = new Component();\n  util.mergeInto(constructor.prototype, oldPrototype);\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/Derby.server.js":"var cluster = require('cluster');\nvar Derby = require('./Derby');\nvar util = require('racer/lib/util');\n\n// Extend template types with html parsing on server\nrequire('derby-parsing');\n\nutil.isProduction = process.env.NODE_ENV === 'production';\n\nDerby.prototype.run = function(createServer) {\n  // In production\n  if (this.util.isProduction) return createServer();\n  if (cluster.isMaster) {\n    console.log('Master pid ', process.pid);\n    startWorker();\n  } else {\n    createServer();\n  }\n};\n\nfunction startWorker() {\n  var worker = cluster.fork();\n  worker.once('disconnect', function () {\n    worker.process.kill();\n  });\n  worker.on('message', function(message) {\n    if (message.type === 'reload') {\n      if (worker.disconnecting) return;\n      console.log('Killing %d', worker.process.pid);\n      worker.process.kill();\n      worker.disconnecting = true;\n      startWorker();\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby-parsing/lib/index.js":"var htmlUtil = require('html-util');\nvar derbyTemplates = require('derby-templates');\nvar templates = derbyTemplates.templates;\nvar expressions = derbyTemplates.expressions;\nvar createPathExpression = require('./createPathExpression');\nvar markup = require('./markup');\n\nexports.createTemplate = createTemplate;\nexports.createStringTemplate = createStringTemplate;\nexports.createExpression = createExpression;\nexports.createPathExpression = createPathExpression;\nexports.markup = markup;\n\n// View.prototype._parse is defined here, so that it doesn't have to\n// be included in the client if templates are all parsed server-side\ntemplates.View.prototype._parse = function() {\n  // Wrap parsing in a try / catch to add context to message when throwing\n  var template;\n  try {\n    if (this.literal) {\n      var source = (this.unminified) ? this.source :\n        // Remove leading and trailing whitespace only lines by default\n        this.source.replace(/^\\s*\\n/, '').replace(/\\s*$/, '');\n      template = new templates.Text(source);\n    } else if (this.string) {\n      template = createStringTemplate(this.source, this);\n    } else {\n      var source = (this.unminified) ? this.source :\n        htmlUtil.minify(this.source).replace(/&sp;/g, ' ');\n      template = createTemplate(source, this);\n    }\n  } catch (err) {\n    var message = '\\n\\nWithin template \"' + this.name + '\":\\n' + this.source;\n    throw appendErrorMessage(err, message);\n  }\n  this.template = template;\n  return template;\n};\n\n// Modified and shared among the following parse functions. It's OK for this\n// to be shared at the module level, since it is only used by synchronous code\nvar parseNode;\n\nfunction createTemplate(source, view) {\n  source = escapeBraced(source);\n  parseNode = new ParseNode(view);\n  htmlUtil.parse(source, {\n    start: parseHtmlStart\n  , end: parseHtmlEnd\n  , text: parseHtmlText\n  , comment: parseHtmlComment\n  , other: parseHtmlOther\n  });\n  // Allow for certain elements at the end of a template to not be closed. This\n  // is especially important so that </body> and </html> tags can be omitted,\n  // since Derby sends an additional script tag after the HTML for the page\n  while (parseNode.parent) {\n    parseNode = parseNode.parent;\n    var last = parseNode.last();\n    if (last instanceof templates.Element) {\n      if (last.tagName === 'body' || last.tagName === 'html') {\n        last.notClosed = true;\n        last.endTag = '';\n        continue;\n      } else {\n        throw new Error('Missing closing HTML tag: ' + last.endTag);\n      }\n    }\n    unexpected();\n  }\n  return new templates.Template(parseNode.content);\n}\n\nfunction createStringTemplate(source, view) {\n  source = escapeBraced(source);\n  parseNode = new ParseNode(view);\n  parseText(source, parseTextLiteral, parseTextExpression, 'string');\n  return new templates.Template(parseNode.content);\n}\n\nfunction parseHtmlStart(tag, tagName, attributes, selfClosing) {\n  var lowerTagName = tagName.toLowerCase();\n  var hooks;\n  if (lowerTagName !== 'view' && !viewForTagName(lowerTagName)) {\n    hooks = elementHooksFromAttributes(attributes);\n  }\n  var attributesMap = parseAttributes(attributes);\n  var namespaceUri = (lowerTagName === 'svg') ?\n    templates.NAMESPACE_URIS.svg : parseNode.namespaceUri;\n  var Constructor = templates.Element;\n  if (lowerTagName === 'tag') {\n    Constructor = templates.DynamicElement;\n    tagName = attributesMap.is;\n    delete attributesMap.is;\n  }\n  if (selfClosing || templates.VOID_ELEMENTS[lowerTagName]) {\n    var element = new Constructor(tagName, attributesMap, null, hooks, selfClosing, null, namespaceUri);\n    parseNode.content.push(element);\n    parseElementClose(lowerTagName);\n  } else {\n    parseNode = parseNode.child();\n    parseNode.namespaceUri = namespaceUri;\n    var element = new Constructor(tagName, attributesMap, parseNode.content, hooks, selfClosing, null, namespaceUri);\n    parseNode.parent.content.push(element);\n  }\n}\n\nfunction parseAttributes(attributes) {\n  var attributesMap;\n  for (var key in attributes) {\n    if (!attributesMap) attributesMap = {};\n\n    var value = attributes[key];\n    var match = /([^:]+):[^:]/.exec(key);\n    var nsUri = match && templates.NAMESPACE_URIS[match[1]];\n    if (value === '' || typeof value !== 'string') {\n      attributesMap[key] = new templates.Attribute(value, nsUri);\n      continue;\n    }\n\n    parseNode = parseNode.child();\n    parseText(value, parseTextLiteral, parseTextExpression, 'attribute');\n\n    if (parseNode.content.length === 1) {\n      var item = parseNode.content[0];\n      attributesMap[key] =\n        (item instanceof templates.Text) ? new templates.Attribute(item.data, nsUri) :\n        (item instanceof templates.DynamicText) ?\n          (item.expression instanceof expressions.LiteralExpression) ?\n            new templates.Attribute(item.expression.value, nsUri) :\n            new templates.DynamicAttribute(item.expression, nsUri) :\n          new templates.DynamicAttribute(item, nsUri);\n\n    } else if (parseNode.content.length > 1) {\n      var template = new templates.Template(parseNode.content, value);\n      attributesMap[key] = new templates.DynamicAttribute(template, nsUri);\n\n    } else {\n      throw new Error('Error parsing ' + key + ' attribute: ' + value);\n    }\n\n    parseNode = parseNode.parent;\n  }\n  return attributesMap;\n}\n\nfunction parseHtmlEnd(tag, tagName) {\n  parseNode = parseNode.parent;\n  var last = parseNode.last();\n  if (!(\n    (last instanceof templates.DynamicElement && tagName.toLowerCase() === 'tag') ||\n    (last instanceof templates.Element && last.tagName === tagName)\n  )) {\n    throw new Error('Mismatched closing HTML tag: ' + tag);\n  }\n  parseElementClose(tagName);\n}\n\nfunction parseElementClose(tagName) {\n  if (tagName === 'view') {\n    var element = parseNode.content.pop();\n    parseViewElement(element);\n    return;\n  }\n  var view = viewForTagName(tagName);\n  if (view) {\n    var element = parseNode.content.pop();\n    parseNamedViewElement(element, view, view.name);\n    return;\n  }\n  var element = parseNode.last();\n  markup.emit('element', element);\n  markup.emit('element:' + tagName, element);\n}\n\nfunction viewForTagName(tagName) {\n  return parseNode.view && parseNode.view.views.tagMap[tagName];\n}\n\nfunction parseHtmlText(data, isRawText) {\n  var environment = (isRawText) ? 'string' : 'html';\n  parseText(data, parseTextLiteral, parseTextExpression, environment);\n}\n\nfunction parseHtmlComment(tag, data) {\n  // Only output comments that start with `<!--[` and end with `]-->`\n  if (!htmlUtil.isConditionalComment(tag)) return;\n  var comment = new templates.Comment(data);\n  parseNode.content.push(comment);\n}\n\nvar doctypeRegExp = /^<!DOCTYPE\\s+([^\\s]+)(?:\\s+(PUBLIC|SYSTEM)\\s+\"([^\"]+)\"(?:\\s+\"([^\"]+)\")?)?\\s*>/i;\n\nfunction parseHtmlOther(tag) {\n  var match = doctypeRegExp.exec(tag);\n  if (match) {\n    var name = match[1];\n    var idType = match[2] && match[2].toLowerCase();\n    var publicId, systemId;\n    if (idType === 'public') {\n      publicId = match[3];\n      systemId = match[4];\n    } else if (idType === 'system') {\n      systemId = match[3];\n    }\n    var doctype = new templates.Doctype(name, publicId, systemId);\n    parseNode.content.push(doctype);\n  } else {\n    unexpected(tag);\n  }\n}\n\nfunction parseTextLiteral(data) {\n  var text = new templates.Text(data);\n  parseNode.content.push(text);\n}\n\nfunction parseTextExpression(source, environment) {\n  var expression = createExpression(source);\n  if (expression.meta.blockType) {\n    parseBlockExpression(expression);\n  } else if (expression.meta.valueType === 'view') {\n    parseViewExpression(expression);\n  } else if (expression.meta.unescaped && environment === 'html') {\n    var html = new templates.DynamicHtml(expression);\n    parseNode.content.push(html);\n  } else {\n    var text = new templates.DynamicText(expression);\n    parseNode.content.push(text);\n  }\n}\n\nfunction parseBlockExpression(expression) {\n  var blockType = expression.meta.blockType;\n\n  // Block ending\n  if (expression.meta.isEnd) {\n    parseNode = parseNode.parent;\n    // Validate that the block ending matches an appropriate block start\n    var last = parseNode.last();\n    var lastExpression = last && (last.expression || (last.expressions && last.expressions[0]));\n    if (!(\n      lastExpression &&\n      (blockType === 'end' && lastExpression.meta.blockType) ||\n      (blockType === lastExpression.meta.blockType)\n    )) {\n      throw new Error('Mismatched closing template tag: ' + expression.meta.source);\n    }\n\n  // Continuing block\n  } else if (blockType === 'else' || blockType === 'else if') {\n    parseNode = parseNode.parent;\n    var last = parseNode.last();\n    parseNode = parseNode.child();\n\n    if (last instanceof templates.ConditionalBlock) {\n      last.expressions.push(expression);\n      last.contents.push(parseNode.content);\n    } else if (last instanceof templates.EachBlock) {\n      if (blockType !== 'else') unexpected(expression.meta.source);\n      last.elseContent = parseNode.content;\n    } else {\n      unexpected(expression.meta.source);\n    }\n\n  // Block start\n  } else {\n    var nextNode = parseNode.child();\n    var block;\n    if (blockType === 'if' || blockType === 'unless') {\n      block = new templates.ConditionalBlock([expression], [nextNode.content]);\n    } else if (blockType === 'each') {\n      block = new templates.EachBlock(expression, nextNode.content);\n    } else {\n      block = new templates.Block(expression, nextNode.content);\n    }\n    parseNode.content.push(block);\n    parseNode = nextNode;\n  }\n}\n\nfunction parseViewElement(element) {\n  // TODO: \"name\" is deprecated in lieu of \"is\". Remove \"name\" in Derby 0.6.0\n  var nameAttribute = element.attributes.is || element.attributes.name;\n  if (!nameAttribute) {\n    throw new Error('The <view> element requires an \"is\" attribute');\n  }\n  delete element.attributes.is;\n  delete element.attributes.name;\n\n  if (nameAttribute.expression) {\n    var viewAttributes = viewAttributesFromElement(element);\n    var componentHooks = componentHooksFromAttributes(viewAttributes);\n    var remaining = element.content || [];\n    var viewInstance = createDynamicViewInstance(nameAttribute.expression, viewAttributes, componentHooks.hooks, componentHooks.initHooks);\n    finishParseViewElement(viewAttributes, remaining, viewInstance);\n  } else {\n    var name = nameAttribute.data;\n    var view = findView(name);\n    parseNamedViewElement(element, view, name);\n  }\n}\n\nfunction findView(name) {\n  var view = parseNode.view.views.find(name, parseNode.view.namespace);\n  if (!view) {\n    var message = parseNode.view.views.findErrorMessage(name);\n    throw new Error(message);\n  }\n  return view;\n}\n\nfunction parseNamedViewElement(element, view, name) {\n  var viewAttributes = viewAttributesFromElement(element);\n  var componentHooks = componentHooksFromAttributes(viewAttributes);\n  var remaining = parseContentAttributes(element.content, view, viewAttributes);\n  var viewInstance = new templates.ViewInstance(view.registeredName, viewAttributes, componentHooks.hooks, componentHooks.initHooks);\n  finishParseViewElement(viewAttributes, remaining, viewInstance);\n}\n\nfunction createDynamicViewInstance(expression, attributes, hooks, initHooks) {\n  var viewInstance = new templates.DynamicViewInstance(expression, attributes, hooks, initHooks);\n  // Wrap the viewInstance in a block with the same expression, so that it is\n  // re-rendered when any of its dependencies change\n  return new templates.Block(expression, [viewInstance]);\n}\n\nfunction finishParseViewElement(viewAttributes, remaining, viewInstance) {\n  if (!viewAttributes.hasOwnProperty('content') && remaining.length) {\n    var template = new templates.Template(remaining);\n    viewAttributes.content = (viewAttributes.within) ? template :\n      new templates.ParentWrapper(template);\n  }\n  parseNode.content.push(viewInstance);\n}\n\nfunction viewAttributesFromElement(element) {\n  var viewAttributes = {};\n  for (var key in element.attributes) {\n    var attribute = element.attributes[key];\n    var camelCased = dashToCamelCase(key);\n    viewAttributes[camelCased] =\n      (attribute.expression instanceof templates.Template) ?\n        new templates.ParentWrapper(attribute.expression) :\n      (attribute.expression instanceof expressions.Expression) ?\n        new templates.ParentWrapper(new templates.DynamicText(attribute.expression), attribute.expression) :\n      attribute.data;\n  }\n  return viewAttributes;\n}\n\nfunction parseAsAttribute(key, value) {\n  var expression = createPathExpression(value);\n  if (!(expression instanceof expressions.PathExpression)) {\n    throw new Error(key + ' attribute must be a path: ' + key + '=\"' + value + '\"');\n  }\n  return expression.segments;\n}\n\nfunction parseAsObjectAttribute(key, value) {\n  var expression = createPathExpression(value);\n  if (!(\n    expression instanceof expressions.SequenceExpression &&\n    expression.args.length === 2 &&\n    expression.args[0] instanceof expressions.PathExpression\n  )) {\n    throw new Error(key + ' attribute requires a path and a key argument: ' + key + '=\"' + value + '\"');\n  }\n  var segments = expression.args[0].segments;\n  var expression = expression.args[1];\n  return {segments: segments, expression: expression};\n}\n\nfunction parseOnAttribute(key, value) {\n  // TODO: Argument checking\n  return createPathExpression(value);\n}\n\nfunction elementHooksFromAttributes(attributes, type) {\n  if (!attributes) return;\n  var hooks = [];\n\n  for (var key in attributes) {\n    var value = attributes[key];\n\n    // Parse `as` assignments\n    if (key === 'as') {\n      var segments = parseAsAttribute(key, value);\n      hooks.push(new templates.AsProperty(segments));\n      delete attributes[key];\n      continue;\n    }\n    if (key === 'as-array') {\n      var segments = parseAsAttribute(key, value);\n      hooks.push(new templates.AsArray(segments));\n      delete attributes[key];\n      continue;\n    }\n    if (key === 'as-object') {\n      var parsed = parseAsObjectAttribute(key, value);\n      hooks.push(new templates.AsObject(parsed.segments, parsed.expression));\n      delete attributes[key];\n      continue;\n    }\n\n    // Parse event listeners\n    var match = /^on-(.+)/.exec(key);\n    var eventName = match && match[1];\n    if (eventName) {\n      var expression = parseOnAttribute(key, value);\n      hooks.push(new templates.ElementOn(eventName, expression));\n      delete attributes[key];\n    }\n  }\n\n  if (hooks.length) return hooks;\n}\n\nfunction componentHooksFromAttributes(attributes) {\n  if (!attributes) return {};\n  var hooks = [];\n  var initHooks = [];\n\n  for (var key in attributes) {\n    var value = attributes[key];\n\n    // Parse `as` assignments\n    if (key === 'as') {\n      var segments = parseAsAttribute(key, value);\n      hooks.push(new templates.AsProperty(segments));\n      delete attributes[key];\n      continue;\n    }\n    if (key === 'asArray') {\n      var segments = parseAsAttribute('as-array', value);\n      hooks.push(new templates.AsArrayComponent(segments));\n      delete attributes[key];\n      continue;\n    }\n    if (key === 'asObject') {\n      var parsed = parseAsObjectAttribute('as-object', value);\n      hooks.push(new templates.AsObjectComponent(parsed.segments, parsed.expression));\n      delete attributes[key];\n      continue;\n    }\n\n    // Parse event listeners\n    var match = /^on([A-Z_].*)/.exec(key);\n    var eventName = match && match[1].charAt(0).toLowerCase() + match[1].slice(1);\n    if (eventName) {\n      var expression = parseOnAttribute(key, value);\n      initHooks.push(new templates.ComponentOn(eventName, expression));\n      delete attributes[key];\n    }\n  }\n\n  return {\n    hooks: (hooks.length) ? hooks : null,\n    initHooks: (initHooks.length) ? initHooks : null\n  };\n}\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-./g, function(match) {\n    return match.charAt(1).toUpperCase();\n  });\n}\n\nfunction parseContentAttributes(content, view, viewAttributes) {\n  var remaining = [];\n  if (!content) return remaining;\n  for (var i = 0, len = content.length; i < len; i++) {\n    var item = content[i];\n    var name = (item instanceof templates.Element) && item.tagName;\n\n    if (name === 'attribute') {\n      var name = parseNameAttribute(item);\n      parseAttributeElement(item, name, viewAttributes);\n\n    } else if (view.attributesMap && view.attributesMap[name]) {\n      parseAttributeElement(item, name, viewAttributes);\n\n    } else if (name === 'array') {\n      var name = parseNameAttribute(item);\n      parseArrayElement(item, name, viewAttributes);\n\n    } else if (view.arraysMap && view.arraysMap[name]) {\n      parseArrayElement(item, view.arraysMap[name], viewAttributes);\n\n    } else {\n      remaining.push(item);\n    }\n  }\n  return remaining;\n}\n\nfunction parseNameAttribute(element) {\n  // TODO: \"name\" is deprecated in lieu of \"is\". Remove \"name\" in Derby 0.6.0\n  var nameAttribute = element.attributes.is || element.attributes.name;\n  var name = nameAttribute.data;\n  if (!name) {\n    throw new Error('The <' + element.tagName + '> element requires a literal \"is\" attribute');\n  }\n  delete element.attributes.is;\n  delete element.attributes.name;\n  return name;\n}\n\nfunction parseAttributeElement(element, name, viewAttributes) {\n  var camelName = dashToCamelCase(name);\n  var content = new templates.Template(element.content);\n  viewAttributes[camelName] = (element.attributes && element.attributes.within) ?\n    content : new templates.ParentWrapper(content);\n}\n\nfunction parseArrayElement(element, name, viewAttributes) {\n  var item = viewAttributesFromElement(element);\n  if (!item.hasOwnProperty('content') && element.content.length) {\n    item.content = new templates.ParentWrapper(\n      new templates.Template(element.content)\n    );\n  }\n  var camelName = dashToCamelCase(name);\n  var viewAttribute = viewAttributes[camelName] ||\n    (viewAttributes[camelName] = []);\n  viewAttribute.push(item);\n}\n\nfunction parseViewExpression(expression) {\n  // If there are multiple arguments separated by commas, they will get parsed\n  // as a SequenceExpression\n  var nameExpression, attributesExpression;\n  if (expression instanceof expressions.SequenceExpression) {\n    nameExpression = expression.args[0];\n    attributesExpression = expression.args[1];\n  } else {\n    nameExpression = expression;\n  }\n\n  var viewAttributes = viewAttributesFromExpression(attributesExpression);\n  var componentHooks = componentHooksFromAttributes(viewAttributes);\n\n  // A ViewInstance has a static name, and a DynamicViewInstance gets its name\n  // at render time\n  var viewInstance;\n  if (nameExpression instanceof expressions.LiteralExpression) {\n    var name = nameExpression.get();\n    // Will throw if the view can't be found immediately\n    findView(name);\n    viewInstance = new templates.ViewInstance(name, viewAttributes, componentHooks.hooks, componentHooks.initHooks);\n  } else {\n    viewInstance = createDynamicViewInstance(nameExpression, viewAttributes, componentHooks.hooks, componentHooks.initHooks);\n  }\n  parseNode.content.push(viewInstance);\n}\n\nfunction viewAttributesFromExpression(expression) {\n  if (!expression) return;\n  var object = objectFromObjectExpression(expression);\n\n  var viewAttributes = {};\n  for (var key in object) {\n    var value = object[key];\n    viewAttributes[key] =\n      (value instanceof expressions.LiteralExpression) ? value.value :\n      (value instanceof expressions.Expression) ?\n        new templates.ParentWrapper(new templates.DynamicText(value), value) :\n      value;\n  }\n  return viewAttributes;\n}\n\nfunction objectFromObjectExpression(expression) {\n  if (expression instanceof expressions.LiteralExpression) {\n    var object = expression.value;\n    if (typeof object !== 'object') unexpected();\n    return object;\n\n  // Get the expressions and keys from a OperatorExpression that would have been\n  // created for an object literal with non-literal properties\n  } else if (expression instanceof expressions.OperatorExpression && expression.name === '{}') {\n    var object = {};\n    var args = expression.args;\n    for (var i = 0, len = args.length; i < len; i += 2) {\n      var key = args[i].value;\n      var value = args[i + 1];\n      object[key] = value;\n    }\n    return object;\n\n  } else {\n    unexpected();\n  }\n}\n\nfunction ParseNode(view, parent) {\n  this.view = view;\n  this.parent = parent;\n  this.content = [];\n  this.namespaceUri = parent && parent.namespaceUri;\n}\nParseNode.prototype.child = function() {\n  return new ParseNode(this.view, this);\n};\nParseNode.prototype.last = function() {\n  return this.content[this.content.length - 1];\n};\n\nfunction escapeBraced(source) {\n  var out = '';\n  parseText(source, onLiteral, onExpression, 'string');\n  function onLiteral(text) {\n    out += text;\n  }\n  function onExpression(text) {\n    var escaped = text.replace(/[&<]/g, function(match) {\n      return (match === '&') ? '&amp;' : '&lt;';\n    });\n    out += '{{' + escaped + '}}';\n  }\n  return out;\n}\n\nfunction unescapeBraced(source) {\n  return source.replace(/(?:&amp;|&lt;)/g, function(match) {\n    return (match === '&amp;') ? '&' : '<';\n  });\n}\n\nfunction unescapeTextLiteral(text, environment) {\n  return (environment === 'html' || environment === 'attribute') ?\n    htmlUtil.unescapeEntities(text) :\n    text;\n}\n\nfunction parseText(data, onLiteral, onExpression, environment) {\n  var current = data;\n  var last;\n  while (current) {\n    if (current === last) throw new Error('Error parsing template text: ' + data);\n    last = current;\n\n    var start = current.indexOf('{{');\n    if (start === -1) {\n      var unescapedCurrent = unescapeTextLiteral(current, environment);\n      onLiteral(unescapedCurrent);\n      return;\n    }\n\n    var end = matchBraces(current, 2, start, '{', '}');\n    if (end === -1) throw new Error('Mismatched braces in: ' + data);\n\n    if (start > 0) {\n      var before = current.slice(0, start);\n      var unescapedBefore = unescapeTextLiteral(before, environment);\n      onLiteral(unescapedBefore);\n    }\n\n    var inside = current.slice(start + 2, end - 2);\n    if (inside) {\n      var unescapedInside = unescapeBraced(inside);\n      unescapedInside = unescapeTextLiteral(unescapedInside, environment);\n      onExpression(unescapedInside, environment);\n    }\n\n    current = current.slice(end);\n  }\n}\n\nfunction matchBraces(text, num, i, openChar, closeChar) {\n  i += num;\n  while (num) {\n    var close = text.indexOf(closeChar, i);\n    var open = text.indexOf(openChar, i);\n    var hasClose = close !== -1;\n    var hasOpen = open !== -1;\n    if (hasClose && (!hasOpen || (close < open))) {\n      i = close + 1;\n      num--;\n      continue;\n    } else if (hasOpen) {\n      i = open + 1;\n      num++;\n      continue;\n    } else {\n      return -1;\n    }\n  }\n  return i;\n}\n\nvar blockRegExp = /^(if|unless|else if|each|with|on)\\s+([\\s\\S]+?)(?:\\s+as\\s+([^,\\s]+)\\s*(?:,\\s*(\\S+))?)?$/;\nvar valueRegExp = /^(?:(view|unbound|bound|unescaped)\\s+)?([\\s\\S]*)/;\n\nfunction createExpression(source) {\n  source = source.trim();\n  var meta = new expressions.ExpressionMeta(source);\n\n  // Parse block expression //\n\n  // The block expressions `if`, `unless`, `else if`, `each`, `with`, and `on`\n  // must have a single blockType keyword and a path. They may have an optional\n  // alias assignment\n  var match = blockRegExp.exec(source);\n  var path;\n  if (match) {\n    meta.blockType = match[1];\n    path = match[2];\n    meta.as = match[3];\n    meta.keyAs = match[4];\n\n  // The blocks `else`, `unbound`, and `bound` may not have a path or alias\n  } else if (source === 'else' || source === 'unbound' || source === 'bound') {\n    meta.blockType = source;\n\n  // Any source that starts with a `/` is treated as an end block. Either a\n  // `{{/}}` with no following characters or a `{{/if}}` style ending is valid\n  } else if (source.charAt(0) === '/') {\n    meta.isEnd = true;\n    meta.blockType = source.slice(1).trim() || 'end';\n\n\n  // Parse value expression //\n\n  // A value expression has zero or many keywords and an expression\n  } else {\n    path = source;\n    var keyword;\n    do {\n      match = valueRegExp.exec(path);\n      keyword = match[1];\n      path = match[2];\n      if (keyword === 'unescaped') {\n        meta.unescaped = true;\n      } else if (keyword === 'unbound' || keyword === 'bound') {\n        meta.bindType = keyword;\n      } else if (keyword) {\n        meta.valueType = keyword;\n      }\n    } while (keyword);\n  }\n\n  // Wrap parsing in a try / catch to add context to message when throwing\n  var expression;\n  try {\n    expression = (path) ?\n      createPathExpression(path) :\n      new expressions.Expression();\n  } catch (err) {\n    var message = '\\n\\nWithin expression: ' + source;\n    throw appendErrorMessage(err, message);\n  }\n  expression.meta = meta;\n  return expression;\n}\n\nfunction unexpected(source) {\n  throw new Error('Error parsing template: ' + source);\n}\n\nfunction appendErrorMessage(err, message) {\n  if (err instanceof Error) {\n    err.message += message;\n    return err;\n  }\n  return new Error(err + message);\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby-parsing/lib/createPathExpression.js":"var derbyTemplates = require('derby-templates');\nvar expressions = derbyTemplates.expressions;\nvar operatorFns = derbyTemplates.operatorFns;\nvar esprima = require('esprima-derby');\nvar Syntax = esprima.Syntax;\n\nmodule.exports = createPathExpression;\n\nfunction createPathExpression(source) {\n  var node = esprima.parse(source).expression;\n  return reduce(node);\n}\n\nfunction reduce(node) {\n  var type = node.type;\n  if (type === Syntax.MemberExpression) {\n    return reduceMemberExpression(node);\n  } else if (type === Syntax.Identifier) {\n    return reduceIdentifier(node);\n  } else if (type === Syntax.ThisExpression) {\n    return reduceThis(node);\n  } else if (type === Syntax.CallExpression) {\n    return reduceCallExpression(node);\n  } else if (type === Syntax.Literal) {\n    return reduceLiteral(node);\n  } else if (type === Syntax.UnaryExpression) {\n    return reduceUnaryExpression(node);\n  } else if (type === Syntax.BinaryExpression || type === Syntax.LogicalExpression) {\n    return reduceBinaryExpression(node);\n  } else if (type === Syntax.ConditionalExpression) {\n    return reduceConditionalExpression(node);\n  } else if (type === Syntax.ArrayExpression) {\n    return reduceArrayExpression(node);\n  } else if (type === Syntax.ObjectExpression) {\n    return reduceObjectExpression(node);\n  } else if (type === Syntax.SequenceExpression) {\n    return reduceSequenceExpression(node);\n  } else if (type === Syntax.NewExpression) {\n    return reduceNewExpression(node);\n  }\n  unexpected(node);\n}\n\nfunction reduceMemberExpression(node, afterSegments) {\n  if (node.computed) {\n    // Square brackets\n    if (node.property.type === Syntax.Literal) {\n      return reducePath(node, node.property.value, afterSegments);\n    }\n    var before = reduce(node.object);\n    var inside = reduce(node.property);\n    return new expressions.BracketsExpression(before, inside, afterSegments);\n  }\n  // Dot notation\n  if (node.property.type === Syntax.Identifier) {\n    return reducePath(node, node.property.name);\n  }\n  unexpected(node);\n}\n\nfunction reducePath(node, segment, afterSegments) {\n  var segments = [segment];\n  if (afterSegments) segments = segments.concat(afterSegments);\n  var relative = false;\n  while (node = node.object) {\n    if (node.type === Syntax.MemberExpression) {\n      if (node.computed) {\n        return reduceMemberExpression(node, segments);\n      } else if (node.property.type === Syntax.Identifier) {\n        segments.unshift(node.property.name);\n      } else {\n        unexpected(node);\n      }\n    } else if (node.type === Syntax.Identifier) {\n      segments.unshift(node.name);\n    } else if (node.type === Syntax.ThisExpression) {\n      relative = true;\n    } else if (node.type === Syntax.CallExpression) {\n      return reduceCallExpression(node, segments);\n    } else if (node.type === Syntax.SequenceExpression) {\n      return reduceSequenceExpression(node, segments);\n    } else if (node.type === Syntax.NewExpression) {\n      return reduceNewExpression(node, segments);\n    } else {\n      unexpected(node);\n    }\n  }\n  return (relative) ?\n    new expressions.RelativePathExpression(segments) :\n    createSegmentsExpression(segments);\n}\n\nfunction reduceIdentifier(node) {\n  var segments = [node.name];\n  return createSegmentsExpression(segments);\n}\n\nfunction reduceThis(node) {\n  var segments = [];\n  return new expressions.RelativePathExpression(segments);\n}\n\nfunction createSegmentsExpression(segments) {\n  var firstSegment = segments[0];\n  var firstChar = firstSegment.charAt && firstSegment.charAt(0);\n\n  if (firstChar === '#') {\n    var alias = firstSegment;\n    segments.shift();\n    return new expressions.AliasPathExpression(alias, segments);\n\n  } else if (firstChar === '@') {\n    var attribute = firstSegment.slice(1);\n    segments.shift();\n    return new expressions.AttributePathExpression(attribute, segments);\n\n  } else {\n    return new expressions.PathExpression(segments);\n  }\n}\n\nfunction reduceCallExpression(node, afterSegments) {\n  return reduceFnExpression(node, afterSegments, expressions.FnExpression);\n}\n\nfunction reduceNewExpression(node, afterSegments) {\n  return reduceFnExpression(node, afterSegments, expressions.NewExpression);\n}\n\nfunction reduceFnExpression(node, afterSegments, Constructor) {\n  var args = node.arguments.map(reduce);\n  var callee = node.callee;\n  if (callee.type === Syntax.Identifier) {\n    if (callee.name === '$at') {\n      return new expressions.ScopedModelExpression(args[0]);\n    }\n    var segments = [callee.name];\n    return new Constructor(segments, args, afterSegments);\n  } else if (callee.type === Syntax.MemberExpression) {\n    var segments = reduceMemberExpression(callee).segments;\n    return new Constructor(segments, args, afterSegments);\n  } else {\n    unexpected(node);\n  }\n}\n\nfunction reduceLiteral(node) {\n  return new expressions.LiteralExpression(node.value);\n}\n\nfunction reduceUnaryExpression(node) {\n  // `-` and `+` can be either unary or binary, so all unary operators are\n  // postfixed with `U` to differentiate\n  var operator = node.operator + 'U';\n  var expression = reduce(node.argument);\n  if (expression instanceof expressions.LiteralExpression) {\n    var fn = operatorFns.get[operator];\n    expression.value = fn(expression.value);\n    return expression;\n  }\n  return new expressions.OperatorExpression(operator, [expression]);\n}\n\nfunction reduceBinaryExpression(node) {\n  var operator = node.operator;\n  var left = reduce(node.left);\n  var right = reduce(node.right);\n  if (\n    left instanceof expressions.LiteralExpression &&\n    right instanceof expressions.LiteralExpression\n  ) {\n    var fn = operatorFns.get[operator];\n    var value = fn(left.value, right.value);\n    return new expressions.LiteralExpression(value);\n  }\n  return new expressions.OperatorExpression(operator, [left, right]);\n}\n\nfunction reduceConditionalExpression(node) {\n  var test = reduce(node.test);\n  var consequent = reduce(node.consequent);\n  var alternate = reduce(node.alternate);\n  if (\n    test instanceof expressions.LiteralExpression &&\n    consequent instanceof expressions.LiteralExpression &&\n    alternate instanceof expressions.LiteralExpression\n  ) {\n    var value = (test.value) ? consequent.value : alternate.value;\n    return new expressions.LiteralExpression(value);\n  }\n  return new expressions.OperatorExpression('?', [test, consequent, alternate]);\n}\n\nfunction reduceArrayExpression(node) {\n  var elements = node.elements;\n  var literal = [];\n  var args = [];\n  var isLiteral = true;\n  for (var i = 0, len = elements.length; i < len; i++) {\n    var expression = reduce(elements[i]);\n    args.push(expression);\n    if (isLiteral && expression instanceof expressions.LiteralExpression) {\n      literal.push(expression.value);\n    } else {\n      isLiteral = false;\n    }\n  }\n  return (isLiteral) ?\n    new expressions.LiteralExpression(literal) :\n    new expressions.OperatorExpression('[]', args);\n}\n\nfunction reduceObjectExpression(node) {\n  var properties = node.properties;\n  var literal = {};\n  var args = [];\n  var isLiteral = true;\n  for (var i = 0, len = properties.length; i < len; i++) {\n    var property = properties[i];\n    var key = getKeyName(property.key);\n    var keyExpression = new expressions.LiteralExpression(key);\n    var expression = reduce(property.value);\n    args.push(keyExpression, expression);\n    if (isLiteral && expression instanceof expressions.LiteralExpression) {\n      literal[key] = expression.value;\n    } else {\n      isLiteral = false;\n    }\n  }\n  return (isLiteral) ?\n    new expressions.LiteralExpression(literal) :\n    new expressions.OperatorExpression('{}', args);\n}\n\nfunction getKeyName(key) {\n  return (key.type === Syntax.Identifier) ? key.name :\n    (key.type === Syntax.Literal) ? key.value :\n    unexpected(key);\n}\n\nfunction reduceSequenceExpression(node, afterSegments) {\n  // Note that sequence expressions are not reduced to a literal if they only\n  // contain literals. There isn't any utility to such an expression, so it\n  // isn't worth optimizing.\n  //\n  // The fact that expressions separated by commas always parse into a sequence\n  // is relied upon in parsing template tags that have comma-separated\n  // arguments following a keyword\n  var args = node.expressions.map(reduce);\n  return new expressions.SequenceExpression(args, afterSegments);\n}\n\nfunction unexpected(node) {\n  throw new Error('Unexpected Esprima node: ' + JSON.stringify(node, null, 2));\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby-parsing/lib/markup.js":"var EventEmitter = require('events').EventEmitter;\nvar templates = require('derby-templates').templates;\nvar createPathExpression = require('./createPathExpression');\n\n// TODO: Should be its own module\n\nvar markup = module.exports = new MarkupParser();\n\nfunction MarkupParser() {\n  EventEmitter.call(this);\n}\nmergeInto(MarkupParser.prototype, EventEmitter.prototype);\n\nmarkup.on('element:a', function(template) {\n  if (hasListenerFor(template, 'click')) {\n    var attributes = template.attributes || (template.attributes = {});\n    if (!attributes.href) {\n      attributes.href = new templates.Attribute('#');\n      addListener(template, 'click', '$preventDefault($event)');\n    }\n  }\n});\n\nmarkup.on('element:form', function(template) {\n  if (hasListenerFor(template, 'submit')) {\n    addListener(template, 'submit', '$preventDefault($event)');\n  }\n});\n\nfunction hasListenerFor(template, eventName) {\n  var hooks = template.hooks;\n  if (!hooks) return false;\n  for (var i = 0, len = hooks.length; i < len; i++) {\n    var hook = hooks[i];\n    if (hook instanceof templates.ElementOn && hook.name === eventName) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction addListener(template, eventName, source) {\n  var hooks = template.hooks || (template.hooks = []);\n  var expression = createPathExpression(source);\n  hooks.push(new templates.ElementOn(eventName, expression));\n}\n\nfunction mergeInto(to, from) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n  return to;\n}\n","/home/travis/build/npmtest/node-npmtest-derby/node_modules/derby/lib/DerbyStandalone.js":"var EventEmitter = require('events').EventEmitter;\nvar Model = require('racer/lib/Model/ModelStandalone');\nvar util = require('racer/lib/util');\nvar App = require('./App');\nvar Page = require('./Page');\nvar components = require('./components');\n\nmodule.exports = DerbyStandalone;\n\nrequire('./documentListeners').add(document);\n\n// Standard Derby inherits from Racer, but we just do set up the event emitter\n// and expose the Model and util here instead\nfunction DerbyStandalone() {\n  EventEmitter.call(this);\n}\nutil.mergeInto(DerbyStandalone.prototype, EventEmitter.prototype);\nDerbyStandalone.prototype.Model = Model;\nDerbyStandalone.prototype.util = util;\n\nDerbyStandalone.prototype.App = App;\nDerbyStandalone.prototype.Page = Page;\nDerbyStandalone.prototype.Component = components.Component;\n\nDerbyStandalone.prototype.createApp = function() {\n  return new App(this);\n};\n\n// Overriden on server\nApp.prototype._init = function() {\n  this.model = new this.derby.Model();\n  this.createPage();\n};\n"}